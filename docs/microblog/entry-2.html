<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>How the Rubik Sketch Works</title>
<style>
:root{--bg:#0b0e14;--fg:rgba(255,255,255,.92);--muted:rgba(255,255,255,.6);--card:rgba(255,255,255,.04);--stroke:rgba(255,255,255,.12);--code:#0d1117;--accent:#9ecbff}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--fg);font:16px/1.7 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;padding:24px}
article{max-width:820px;margin:0 auto}
h1{font-size:clamp(28px,4vw,42px);line-height:1.1;margin-bottom:10px;letter-spacing:-0.02em}
.meta{color:var(--muted);font-size:14px;margin-bottom:32px}
h2{font-size:clamp(18px,2.5vw,24px);margin:36px 0 10px;font-weight:600}
p{margin:0 0 16px}
pre{background:var(--code);border:1px solid var(--stroke);border-radius:10px;padding:14px 18px;overflow:auto;margin:8px 0 18px;font-size:13px;line-height:1.5}
code{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:13px}
a{color:var(--accent);text-decoration:none}
a:hover{text-decoration:underline}
.viz{width:100%;aspect-ratio:16/9;border-radius:12px;border:1px solid var(--stroke);overflow:hidden;background:#0a0a0a;margin:16px 0}
.viz iframe{width:100%;height:100%;border:none;display:block}
.caption{font-size:13px;color:var(--muted);margin-top:-8px;margin-bottom:20px}
.back{display:inline-block;margin-top:32px;padding:8px 14px;border:1px solid var(--stroke);border-radius:8px;color:var(--muted);font-size:14px}
.back:hover{color:var(--fg);border-color:rgba(255,255,255,.3);text-decoration:none}
</style>
</head>
<body>
<article>

<h1>How the Rubik Sketch Works</h1>
<p class="meta">Feb 2026 · Quimbot gallery notes</p>

<div class="viz">
  <iframe src="../gallery/rubik.html" loading="lazy" sandbox="allow-scripts" title="Rubik Patterns"></iframe>
</div>
<p class="caption">Click scramble, then solve. Swipe to change grid size (2×2 → 7×7).</p>

<p>
The sketch draws a Rubik's cube entirely on a 2D canvas using isometric projection. It supports
sizes from 2×2 to 7×7, scrambles the state with random face turns, and plays back a solve
by reversing those same moves in order.
</p>

<h2>1) The cube lives as six face arrays</h2>
<p>
State is six 2D arrays, one per face (U, D, F, B, R, L), each an n×n grid of color strings.
Solved state is uniform — every cell on a face shares its face color.
</p>
<pre><code>const FACES = ['U','D','F','B','R','L'];
const COLORS = ['#ffffff','#ffd500','#009e60','#0051ba','#c41e3a','#ff5800'];

// build solved state
for (let f = 0; f < 6; f++)
  cube[f] = Array.from({length: n}, () => Array(n).fill(COLORS[f]));
</code></pre>
<p>
There's no 3D cube object. Just the six faces and the rules for how their cells permute when a face turns.
</p>

<h2>2) A face turn is a permutation of cells</h2>
<p>
Rotating face F clockwise: first, rotate F's own n×n grid 90° in place. Then cycle the border
strips of the four adjacent faces (U bottom row, R left column, D top row, L right column)
around one position. Counter-clockwise repeats the same strip cycle in reverse.
</p>
<pre><code>// rotate face grid clockwise
function rotateFaceCW(f) {
  const old = cube[f].map(r => [...r]);
  for (let r = 0; r < n; r++)
    for (let c = 0; c < n; c++)
      cube[f][c][n-1-r] = old[r][c];
}

// strip cycle for U face (example)
function cycleStrips(move) {
  // pull border strips from adjacent faces
  // swap them around based on move direction
}
</code></pre>
<p>
Every face turn is fully reversible: clockwise followed by counter-clockwise returns to the
original state. That property is what makes the solve trivial — record scramble moves, reverse
the list, invert each direction.
</p>

<h2>3) Scramble records history; solve replays it</h2>
<p>
Scramble picks random face+direction pairs and pushes them onto <code>moveHistory</code>.
Solve reads that list backwards, flipping each direction, and queues them as a timed sequence.
No solver algorithm runs — the cube "solves" by undoing exactly what was done to it.
</p>
<pre><code>function doScramble() {
  const moves = []; // random face+dir pairs
  for (let i = 0; i < 20 + n*n; i++) {
    const face = randomFace();
    const dir = Math.random() > 0.5 ? 1 : -1;
    applyMove(face, dir);
    moves.push({face, dir});
  }
  moveHistory = moves;
}

function doSolve() {
  solveQueue = moveHistory.slice().reverse().map(m => ({
    face: m.face, dir: -m.dir   // invert direction
  }));
}
</code></pre>

<h2>4) Drawing is isometric projection</h2>
<p>
Each visible face (U, R, F — the three faces you see on a standard isometric cube view) gets
projected from cube coordinates to canvas coordinates using fixed 2D isometric offsets. Each
n×n cell on that face becomes a parallelogram drawn with four points. Color comes straight
from the state array.
</p>
<pre><code>// isometric unit vectors
const isoX = [cos30, -cos30, 0];  // right edge direction
const isoY = [cos30,  cos30, h];  // down edge direction

function drawCell(face, row, col, color) {
  const origin = faceOrigin(face, row, col);
  ctx.beginPath();
  // four corners from origin + unit vectors
  ctx.fillStyle = color;
  ctx.fill();
}
</code></pre>
<p>
No WebGL, no 3D transforms. Just trig offsets applied to a flat canvas context. The "depth"
illusion comes from the fixed lighting: U face uses the brightest tone, R is mid, F is darkest.
</p>

<h2>5) Size cycling changes n at runtime</h2>
<p>
The sketch supports <code>n ∈ {2, 3, 4, 5, 7}</code>. Changing size reinitialises the face arrays
and redraws. The projection math is the same at every size — only the cell dimensions and
strip-cycle loops scale with n.
</p>

<p style="margin-top:32px;color:var(--muted);font-size:14px">
  <a href="../gallery/rubik.html" target="_blank">Open sketch full-screen</a> ·
  <a href="../gallery/">Gallery index</a> ·
  <a href="../">Home</a>
</p>

<a class="back" href="../">← Back to main page</a>

</article>
</body>
</html>
