<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mitosis</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #0a0a0a; overflow: hidden; }
  canvas { display: block; }
  #back { position: fixed; top: 1rem; left: 1rem; background: #222; color: #ccc; border: 1px solid #444; padding: 0.4rem 0.9rem; border-radius: 4px; cursor: pointer; font-family: monospace; font-size: 0.8rem; z-index: 10; text-decoration: none; }
  #back:hover { background: #333; }
</style>
</head>
<body>
<a id="back" href="index.html">‚Üê gallery</a>
<canvas id="c"></canvas>
<script>
if (window.self !== window.top) { document.getElementById('back').style.display = 'none'; }

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;
function resize() { W = canvas.width = innerWidth; H = canvas.height = innerHeight; }
resize();
addEventListener('resize', resize);

class Cell {
  constructor(x, y, r, hue) {
    this.x = x; this.y = y; this.r = r;
    this.hue = hue || Math.random() * 360;
    this.vx = (Math.random() - 0.5) * 0.5;
    this.vy = (Math.random() - 0.5) * 0.5;
    this.age = 0;
    this.maxAge = 300 + Math.random() * 400;
    this.phase = 0; // 0=growth, 1=splitting
    this.splitProgress = 0;
    this.maxR = r * (1.4 + Math.random() * 0.4);
    this.nucleusPhase = Math.random() * Math.PI * 2;
  }

  update(cells) {
    this.age++;
    this.nucleusPhase += 0.02;

    // Repel from others
    for (const o of cells) {
      if (o === this) continue;
      const dx = this.x - o.x, dy = this.y - o.y;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      const minD = this.r + o.r + 2;
      if (dist < minD) {
        const f = (minD - dist) / minD * 0.3;
        this.vx += (dx / dist) * f;
        this.vy += (dy / dist) * f;
      }
    }

    // Boundary
    if (this.x < this.r) this.vx += 0.2;
    if (this.x > W - this.r) this.vx -= 0.2;
    if (this.y < this.r) this.vy += 0.2;
    if (this.y > H - this.r) this.vy -= 0.2;

    this.vx *= 0.98; this.vy *= 0.98;
    this.x += this.vx; this.y += this.vy;

    if (this.phase === 0) {
      this.r += (this.maxR - this.r) * 0.005;
      if (this.age > this.maxAge * 0.7) this.phase = 1;
    } else {
      this.splitProgress += 0.008;
    }

    return this.splitProgress >= 1;
  }

  split() {
    const angle = Math.random() * Math.PI * 2;
    const newR = this.r * 0.6;
    const offset = newR * 0.8;
    const hueShift = (Math.random() - 0.5) * 20;
    return [
      new Cell(this.x + Math.cos(angle) * offset, this.y + Math.sin(angle) * offset, newR, this.hue + hueShift),
      new Cell(this.x - Math.cos(angle) * offset, this.y - Math.sin(angle) * offset, newR, this.hue - hueShift),
    ];
  }

  draw() {
    const alpha = this.phase === 1 ? 1 - this.splitProgress * 0.3 : Math.min(1, this.age / 30);

    // Membrane
    ctx.beginPath();
    if (this.phase === 1) {
      const pinch = this.splitProgress * this.r * 0.4;
      const angle = this.nucleusPhase;
      ctx.ellipse(this.x, this.y, this.r, this.r - pinch, angle, 0, Math.PI * 2);
    } else {
      ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
    }
    ctx.fillStyle = `hsla(${this.hue}, 60%, 25%, ${alpha * 0.6})`;
    ctx.fill();
    ctx.strokeStyle = `hsla(${this.hue}, 70%, 50%, ${alpha * 0.8})`;
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Nucleus
    const nr = this.r * 0.3;
    if (this.phase === 1 && this.splitProgress > 0.3) {
      const sep = this.splitProgress * this.r * 0.3;
      const a = this.nucleusPhase;
      ctx.beginPath();
      ctx.arc(this.x + Math.cos(a) * sep, this.y + Math.sin(a) * sep, nr * 0.7, 0, Math.PI * 2);
      ctx.fillStyle = `hsla(${this.hue + 30}, 80%, 40%, ${alpha * 0.9})`;
      ctx.fill();
      ctx.beginPath();
      ctx.arc(this.x - Math.cos(a) * sep, this.y - Math.sin(a) * sep, nr * 0.7, 0, Math.PI * 2);
      ctx.fill();
    } else {
      ctx.beginPath();
      ctx.arc(this.x + Math.sin(this.nucleusPhase) * 2, this.y + Math.cos(this.nucleusPhase) * 2, nr, 0, Math.PI * 2);
      ctx.fillStyle = `hsla(${this.hue + 30}, 80%, 40%, ${alpha * 0.9})`;
      ctx.fill();
    }

    // Organelles
    for (let i = 0; i < 4; i++) {
      const a = this.nucleusPhase + i * Math.PI / 2;
      const d = this.r * 0.55;
      ctx.beginPath();
      ctx.arc(this.x + Math.cos(a) * d, this.y + Math.sin(a) * d, 2, 0, Math.PI * 2);
      ctx.fillStyle = `hsla(${this.hue - 40}, 50%, 50%, ${alpha * 0.5})`;
      ctx.fill();
    }
  }
}

let cells = [];
const MAX_CELLS = 80;

// Seed
for (let i = 0; i < 8; i++) {
  cells.push(new Cell(
    W * 0.2 + Math.random() * W * 0.6,
    H * 0.2 + Math.random() * H * 0.6,
    15 + Math.random() * 10
  ));
}

canvas.addEventListener('click', e => {
  if (cells.length < MAX_CELLS) {
    cells.push(new Cell(e.clientX, e.clientY, 12 + Math.random() * 8));
  }
});

function frame() {
  ctx.fillStyle = 'rgba(10, 10, 10, 0.15)';
  ctx.fillRect(0, 0, W, H);

  const newCells = [];
  for (const cell of cells) {
    const ready = cell.update(cells);
    if (ready && cells.length + newCells.length < MAX_CELLS) {
      newCells.push(...cell.split());
    } else if (ready) {
      // Reset instead of splitting
      cell.phase = 0;
      cell.splitProgress = 0;
      cell.age = 0;
      cell.maxAge = 300 + Math.random() * 400;
      newCells.push(cell);
    } else {
      newCells.push(cell);
    }
  }

  // Cull if too many (remove oldest)
  newCells.sort((a, b) => b.age - a.age);
  cells = newCells.slice(0, MAX_CELLS);

  for (const cell of cells) cell.draw();

  requestAnimationFrame(frame);
}
frame();
</script>
</body>
</html>
