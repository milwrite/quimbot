<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+CiAgPHJlY3QgZmlsbD0iIzA1MDUwNSIgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIi8+CiAgPGNpcmNsZSBjeD0iMTYiIGN5PSIxNiIgcj0iOCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNTU1IiBzdHJva2Utd2lkdGg9IjIiLz4KPC9zdmc+"/>
<title>Chainwheel</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #050505; overflow: hidden; }
canvas { display: block; width: 100vw; height: 100vh; }
.back-btn {
  position: fixed; top: 16px; right: 16px;
  background: rgba(8,8,8,0.92); border: 1px solid #2a2a2a;
  color: #666; padding: 8px 14px; border-radius: 4px;
  font: 12px ui-monospace, SFMono-Regular, Menlo, monospace;
  cursor: pointer; text-decoration: none; z-index: 1000;
  transition: border-color 0.2s, color 0.2s;
}
.back-btn:hover { border-color: #555; color: #aaa; }
</style>
</head>
<body>
<a href="./" class="back-btn">← Gallery</a>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const inIframe = window.self !== window.top;
if (inIframe) document.querySelector('.back-btn').style.display = 'none';

let W, H, S;
function resize() {
  W = canvas.width  = window.innerWidth;
  H = canvas.height = window.innerHeight;
  S = Math.min(W, H);
}
window.addEventListener('resize', () => { resize(); buildGears(); });
resize();

let masterAngle = 0;
const MASTER_SPEED = 0.006;

// ─── GEAR SPECS ───────────────────────────────────────────────────────────────
// [xFrac, yFrac, rFrac, shade]  shade 0=darkest 1=lightest
const SPECS = [
  // 0  master center
  [0.500, 0.500, 0.110, 0.55],
  // 1-4  inner cardinal ring
  [0.680, 0.500, 0.062, 0.40],
  [0.320, 0.500, 0.062, 0.40],
  [0.500, 0.680, 0.062, 0.40],
  [0.500, 0.320, 0.062, 0.40],
  // 5-8  diagonal mid
  [0.760, 0.295, 0.044, 0.32],
  [0.240, 0.295, 0.044, 0.32],
  [0.760, 0.705, 0.044, 0.32],
  [0.240, 0.705, 0.044, 0.32],
  // 9-12  cardinal far
  [0.820, 0.500, 0.034, 0.50],
  [0.180, 0.500, 0.034, 0.50],
  [0.500, 0.175, 0.034, 0.50],
  [0.500, 0.825, 0.034, 0.50],
  // 13-16  corner mid
  [0.880, 0.200, 0.027, 0.62],
  [0.120, 0.200, 0.027, 0.62],
  [0.880, 0.800, 0.027, 0.62],
  [0.120, 0.800, 0.027, 0.62],
  // 17-20  far edge
  [0.930, 0.500, 0.020, 0.45],
  [0.070, 0.500, 0.020, 0.45],
  [0.500, 0.085, 0.020, 0.45],
  [0.500, 0.915, 0.020, 0.45],
  // 21-24  extreme corners
  [0.920, 0.120, 0.018, 0.70],
  [0.080, 0.120, 0.018, 0.70],
  [0.920, 0.880, 0.018, 0.70],
  [0.080, 0.880, 0.018, 0.70],
  // 25-28  top/bottom edge fillers
  [0.740, 0.095, 0.022, 0.55],
  [0.260, 0.095, 0.022, 0.55],
  [0.740, 0.905, 0.022, 0.55],
  [0.260, 0.905, 0.022, 0.55],
  // 29-32  left/right side fillers
  [0.092, 0.360, 0.019, 0.58],
  [0.908, 0.360, 0.019, 0.58],
  [0.092, 0.640, 0.019, 0.58],
  [0.908, 0.640, 0.019, 0.58],
];

// ─── CONNECTIONS ──────────────────────────────────────────────────────────────
// All are chain drives. Propagation direction: -1 opposite, +1 same
const CONNS = [
  [0,1],[0,2],[0,3],[0,4],           // master -> inner ring
  [1,5],[4,5],                       // top-right
  [2,6],[4,6],                       // top-left
  [1,7],[3,7],                       // bottom-right
  [2,8],[3,8],                       // bottom-left
  [1,9],[2,10],[4,11],[3,12],        // inner -> cardinal far
  [5,13],[9,13],                     // top-right corner
  [6,14],[10,14],                    // top-left corner
  [7,15],[9,15],                     // bottom-right corner
  [8,16],[10,16],                    // bottom-left corner
  [9,17],[10,18],[11,19],[12,20],    // far edges
  [13,21],[11,25],                   // top-right extreme + filler
  [14,22],[11,26],                   // top-left
  [15,23],[12,27],                   // bottom-right
  [16,24],[12,28],                   // bottom-left
  [10,29],[18,29],                   // left side
  [9,30],[17,30],                    // right side
  [10,31],[18,31],                   // left lower
  [9,32],[17,32],                    // right lower
  [19,25],[19,26],                   // top edge
  [20,27],[20,28],                   // bottom edge
];

let gears = [];
function buildGears() {
  gears = SPECS.map(([xf, yf, rf, shade]) => {
    const r = rf * S;
    const teeth = Math.max(8, Math.round(2 * Math.PI * r / (S * 0.017)));
    return { x: xf * W, y: yf * H, r, teeth, shade, angle: 0, xf, yf, rf };
  });
}
buildGears();

// ─── ANGLE PROPAGATION ────────────────────────────────────────────────────────
function solveAngles() {
  gears[0].angle = masterAngle;
  const solved = new Set([0]);
  const queue = [0];
  while (queue.length) {
    const idx = queue.shift();
    for (const [a, b] of CONNS) {
      let src = -1, dst = -1;
      if (a === idx && !solved.has(b)) { src = a; dst = b; }
      if (b === idx && !solved.has(a)) { src = b; dst = a; }
      if (dst === -1) continue;
      const ratio = gears[src].r / gears[dst].r;
      gears[dst].angle = -gears[src].angle * ratio;
      solved.add(dst);
      queue.push(dst);
    }
  }
}

// ─── CHAIN LINK RENDERING ─────────────────────────────────────────────────────
function chainTangents(g1, g2) {
  const dx = g2.x - g1.x, dy = g2.y - g1.y;
  const d  = Math.hypot(dx, dy);
  const baseA = Math.atan2(dy, dx);
  const r1 = g1.r, r2 = g2.r;
  const raw = (r2 - r1) / d;
  const sinA = Math.max(-0.95, Math.min(0.95, raw));
  const offA  = Math.asin(sinA);

  const topA1 = baseA + Math.PI / 2 - offA;
  const topA2 = baseA + Math.PI / 2 - offA;
  const botA1 = baseA - Math.PI / 2 + offA;
  const botA2 = baseA - Math.PI / 2 + offA;

  return {
    tp1: { x: g1.x + r1 * Math.cos(topA1), y: g1.y + r1 * Math.sin(topA1) },
    tp2: { x: g2.x + r2 * Math.cos(topA2), y: g2.y + r2 * Math.sin(topA2) },
    bp1: { x: g1.x + r1 * Math.cos(botA1), y: g1.y + r1 * Math.sin(botA1) },
    bp2: { x: g2.x + r2 * Math.cos(botA2), y: g2.y + r2 * Math.sin(botA2) },
  };
}

function drawLinksAlong(p1, p2, pitch, phase) {
  const segLen = Math.hypot(p2.x - p1.x, p2.y - p1.y);
  if (segLen < pitch) return;
  const segA = Math.atan2(p2.y - p1.y, p2.x - p1.x);
  const count = Math.ceil(segLen / pitch) + 2;
  const lh = pitch * 0.82;
  const lw = pitch * 0.38;

  for (let i = -1; i <= count; i++) {
    let d = (i * pitch + phase) % segLen;
    if (d < 0) d += segLen;
    if (d > segLen) continue;
    const frac = d / segLen;
    const x = p1.x + (p2.x - p1.x) * frac;
    const y = p1.y + (p2.y - p1.y) * frac;
    drawLink(x, y, segA, lh, lw, i % 2 === 0);
  }
}

function drawLink(x, y, angle, len, w, outer) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);

  const hl = len / 2;
  const hw = w / 2;
  const cr = hw * 0.55;

  ctx.beginPath();
  ctx.moveTo(-hl + cr, -hw);
  ctx.lineTo(hl - cr, -hw);
  ctx.arcTo(hl, -hw, hl, 0, cr);
  ctx.arcTo(hl, hw, hl - cr, hw, cr);
  ctx.lineTo(-hl + cr, hw);
  ctx.arcTo(-hl, hw, -hl, 0, cr);
  ctx.arcTo(-hl, -hw, -hl + cr, -hw, cr);
  ctx.closePath();

  ctx.fillStyle   = outer ? '#242424' : '#161616';
  ctx.strokeStyle = outer ? '#4a4a4a' : '#303030';
  ctx.lineWidth   = 0.7;
  ctx.fill();
  ctx.stroke();

  // pin holes
  const pinR   = hw * 0.42;
  const pinOff = hl - hw * 0.9;
  for (const ox of [-pinOff, pinOff]) {
    ctx.beginPath();
    ctx.arc(ox, 0, pinR, 0, Math.PI * 2);
    ctx.fillStyle = outer ? '#0a0a0a' : '#2e2e2e';
    ctx.fill();
    if (!outer) {
      ctx.strokeStyle = '#484848';
      ctx.lineWidth   = 0.5;
      ctx.stroke();
    }
  }
  ctx.restore();
}

function drawChain(g1, g2) {
  const { tp1, tp2, bp1, bp2 } = chainTangents(g1, g2);
  const pitch = Math.max(S * 0.009, g1.r * 2 * Math.PI / g1.teeth);
  const phase = ((g1.angle * g1.r) % pitch + pitch) % pitch;
  drawLinksAlong(tp1, tp2, pitch, phase);
  drawLinksAlong(bp2, bp1, pitch, (pitch - phase) % pitch); // bottom runs opposite
}

// ─── GEAR RENDERING ───────────────────────────────────────────────────────────
function drawGear(g) {
  const { x, y, r, teeth, angle, shade } = g;
  const toothH = r * 0.20;
  const innerR = r - toothH;
  const pitch  = (2 * Math.PI) / teeth;
  const tw     = pitch * 0.36;

  // steel gray palette derived from shade
  const base  = Math.round(18 + shade * 38);   // 18–56
  const mid   = Math.round(40 + shade * 44);   // 40–84
  const hi    = Math.round(72 + shade * 80);   // 72–152
  const c0    = `rgb(${base},${base},${base})`;
  const c1    = `rgb(${mid},${mid},${mid})`;
  const c2    = `rgb(${hi},${hi},${hi})`;

  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);

  // drop shadow
  const shadow = ctx.createRadialGradient(r * 0.15, r * 0.15, innerR * 0.3, 0, 0, r + toothH * 3);
  shadow.addColorStop(0, 'rgba(0,0,0,0)');
  shadow.addColorStop(1, 'rgba(0,0,0,0.65)');
  ctx.beginPath();
  ctx.arc(0, 0, r + toothH * 3, 0, Math.PI * 2);
  ctx.fillStyle = shadow;
  ctx.fill();

  // gear body path with trapezoidal teeth
  ctx.beginPath();
  for (let i = 0; i < teeth; i++) {
    const a0 = i * pitch;
    const a1 = a0 + tw * 0.2;
    const a2 = a0 + tw;
    const a3 = a0 + tw * 1.55;
    const a4 = a0 + pitch;
    ctx.arc(0, 0, innerR, a0 - tw * 0.15, a1);
    ctx.lineTo(Math.cos(a1) * r, Math.sin(a1) * r);
    ctx.arc(0, 0, r, a1, a2);
    ctx.lineTo(Math.cos(a3) * innerR, Math.sin(a3) * innerR);
    ctx.arc(0, 0, innerR, a3, a4);
  }
  ctx.closePath();

  const bodyGrd = ctx.createRadialGradient(-r * 0.25, -r * 0.25, 0, 0, 0, r);
  bodyGrd.addColorStop(0, `rgb(${base+22},${base+22},${base+22})`);
  bodyGrd.addColorStop(1, c0);
  ctx.fillStyle = bodyGrd;
  ctx.fill();
  ctx.strokeStyle = c1;
  ctx.lineWidth   = 1.2;
  ctx.stroke();

  // machined groove around inner rim
  ctx.beginPath();
  ctx.arc(0, 0, innerR * 0.88, 0, Math.PI * 2);
  ctx.strokeStyle = `rgb(${base-4},${base-4},${base-4})`;
  ctx.lineWidth   = innerR * 0.10;
  ctx.stroke();

  // spokes
  const nSpokes = Math.max(4, Math.floor(teeth / 6));
  const spokeW  = Math.max(1.2, innerR * 0.08);
  for (let i = 0; i < nSpokes; i++) {
    const a   = (i / nSpokes) * Math.PI * 2;
    const sx0 = Math.cos(a) * innerR * 0.22;
    const sy0 = Math.sin(a) * innerR * 0.22;
    const sx1 = Math.cos(a) * innerR * 0.80;
    const sy1 = Math.sin(a) * innerR * 0.80;
    const sg  = ctx.createLinearGradient(sx0, sy0, sx1, sy1);
    sg.addColorStop(0, c1);
    sg.addColorStop(1, `rgb(${base+10},${base+10},${base+10})`);
    ctx.strokeStyle = sg;
    ctx.lineWidth   = spokeW;
    ctx.lineCap     = 'round';
    ctx.beginPath();
    ctx.moveTo(sx0, sy0);
    ctx.lineTo(sx1, sy1);
    ctx.stroke();
    ctx.lineCap = 'butt';
  }

  // hub disk
  ctx.beginPath();
  ctx.arc(0, 0, innerR * 0.21, 0, Math.PI * 2);
  const hubGrd = ctx.createRadialGradient(-innerR * 0.07, -innerR * 0.07, 0, 0, 0, innerR * 0.21);
  hubGrd.addColorStop(0, `rgb(${mid+12},${mid+12},${mid+12})`);
  hubGrd.addColorStop(1, `rgb(${base+6},${base+6},${base+6})`);
  ctx.fillStyle   = hubGrd;
  ctx.strokeStyle = c2;
  ctx.lineWidth   = 0.9;
  ctx.fill();
  ctx.stroke();

  // center bolt
  ctx.beginPath();
  ctx.arc(0, 0, innerR * 0.085, 0, Math.PI * 2);
  ctx.fillStyle = c2;
  ctx.fill();

  // specular sheen on body
  const sheen = ctx.createLinearGradient(-r * 0.55, -r * 0.55, r * 0.1, r * 0.1);
  sheen.addColorStop(0, `rgba(${hi},${hi},${hi},0.10)`);
  sheen.addColorStop(1, `rgba(${hi},${hi},${hi},0)`);
  ctx.beginPath();
  ctx.arc(0, 0, r, 0, Math.PI * 2);
  ctx.fillStyle = sheen;
  ctx.fill();

  ctx.restore();
}

// ─── BACKGROUND ───────────────────────────────────────────────────────────────
function drawBackground() {
  ctx.fillStyle = '#050505';
  ctx.fillRect(0, 0, W, H);

  // hairline cross-grid
  const step = Math.round(S * 0.038);
  ctx.strokeStyle = 'rgba(255,255,255,0.025)';
  ctx.lineWidth   = 0.5;
  for (let x = 0; x <= W; x += step) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
  }
  for (let y = 0; y <= H; y += step) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
  }

  // vignette
  const vig = ctx.createRadialGradient(W / 2, H / 2, S * 0.18, W / 2, H / 2, S * 0.85);
  vig.addColorStop(0, 'rgba(0,0,0,0)');
  vig.addColorStop(1, 'rgba(0,0,0,0.72)');
  ctx.fillStyle = vig;
  ctx.fillRect(0, 0, W, H);
}

// ─── MAIN LOOP ────────────────────────────────────────────────────────────────
function loop() {
  masterAngle += MASTER_SPEED;
  solveAngles();

  drawBackground();

  // chains behind gears
  for (const [i, j] of CONNS) {
    drawChain(gears[i], gears[j]);
  }

  // gears on top
  for (const g of gears) drawGear(g);

  // watermark
  if (!inIframe) {
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.font      = `${Math.max(10, Math.round(S * 0.011))}px ui-monospace, SFMono-Regular, Menlo, monospace`;
    ctx.fillText('CHAINWHEEL', 18, H - 18);
  }

  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
