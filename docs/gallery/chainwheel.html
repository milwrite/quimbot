<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chainwheel System</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #111210; overflow: hidden; }
canvas { display: block; touch-action: none; }
.controls {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  display: flex; gap: 12px; background: rgba(0,0,0,0.8);
  padding: 10px 18px; border-radius: 8px;
  font-family: ui-monospace,monospace; color: #666; font-size: 13px; align-items: center;
}
button {
  background: #1c1c1c; color: #777; border: 1px solid #2e2e2e;
  padding: 6px 14px; border-radius: 4px; cursor: pointer;
  font-family: ui-monospace,monospace; font-size: 13px;
}
button:hover { background: #242424; color: #aaa; }
.back-btn {
  position: fixed; top: 16px; right: 16px;
  background: rgba(16,16,14,0.9); border: 1px solid #2a2a2a;
  color: #666; padding: 8px 14px; border-radius: 6px;
  font: 12px ui-monospace,monospace; cursor: pointer;
  text-decoration: none; backdrop-filter: blur(8px); z-index: 100;
}
.back-btn:hover { color: #999; border-color: #444; }
</style>
</head>
<body>
<a href="./" class="back-btn">← Gallery</a>
<canvas id="c"></canvas>
<div class="controls">
  <button onclick="togglePause()">Pause</button>
  <button onclick="reverseDir()">Reverse</button>
  <span>Mechanical Assembly</span>
</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// Hide chrome when embedded
if (window.self !== window.top) {
  document.querySelector('.back-btn').style.display = 'none';
  document.querySelector('.controls').style.display = 'none';
}

// --- State ---
let W, H, dpr;
let paused = false;
let dir = 1;
let gears = [];
let chains = [];

// --- Resize + DPR ---
function resize() {
  dpr = window.devicePixelRatio || 1;
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = Math.round(W * dpr);
  canvas.height = Math.round(H * dpr);
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  buildSystem();
}
window.addEventListener('resize', resize);
window.addEventListener('orientationchange', () => setTimeout(resize, 150));

// --- Noise ---
function noise(x, y) {
  const v = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
  return v - Math.floor(v);
}

// --- Build system ---
function buildSystem() {
  gears = [];
  chains = [];

  const COLS = 7, ROWS = 5;
  const cellW = W / COLS;
  const cellH = H / ROWS;
  // Max radius: gear diameter = cell short-side * 0.72 → radius = 0.36
  const maxR = Math.min(cellW, cellH) * 0.36;

  for (let row = 0; row < ROWS; row++) {
    for (let col = 0; col < COLS; col++) {
      // Gear center: cell center + tiny jitter (≤10% of cell), stays well inside cell
      const cx = (col + 0.5) * cellW + (Math.random() - 0.5) * cellW * 0.1;
      const cy = (row + 0.5) * cellH + (Math.random() - 0.5) * cellH * 0.1;
      const r  = maxR * (0.5 + Math.random() * 0.5);
      const teeth  = Math.max(8, Math.round(r * 1.6));
      const variant = Math.floor(Math.random() * 3); // 0=rings, 1=spokes, 2=solid
      gears.push({ cx, cy, r, teeth, variant, angle: Math.random() * Math.PI * 2, speed: 0 });
    }
  }

  // Connect grid neighbours — right and down — so the network spans the whole canvas
  // Skip ~25% of connections randomly to leave some gears isolated
  for (let row = 0; row < ROWS; row++) {
    for (let col = 0; col < COLS; col++) {
      const i = row * COLS + col;
      // Connect to right neighbour
      if (col < COLS - 1 && Math.random() > 0.25) {
        const j = row * COLS + (col + 1);
        const g1 = gears[i], g2 = gears[j];
        if (Math.hypot(g2.cx - g1.cx, g2.cy - g1.cy) > g1.r + g2.r + 3)
          chains.push({ i, j, type: 'chain', offset: 0 });
      }
      // Connect to bottom neighbour
      if (row < ROWS - 1 && Math.random() > 0.25) {
        const j = (row + 1) * COLS + col;
        const g1 = gears[i], g2 = gears[j];
        if (Math.hypot(g2.cx - g1.cx, g2.cy - g1.cy) > g1.r + g2.r + 3)
          chains.push({ i, j, type: 'mesh', offset: 0 });
      }
    }
  }

  // Find largest gear by index (don't sort — that would invalidate chain indices)
  let masterIdx = 0;
  for (let i = 1; i < gears.length; i++) {
    if (gears[i].r > gears[masterIdx].r) masterIdx = i;
  }
  gears[masterIdx].speed = 0.007;
  propagate();
}

function propagate() {
  for (let i = 1; i < gears.length; i++) gears[i].speed = 0;
  let changed = true, iter = 0;
  while (changed && iter++ < 200) {
    changed = false;
    for (const { i, j, type } of chains) {
      const a = gears[i], b = gears[j];
      const sign = type === 'chain' ? 1 : -1;
      const ratio = a.r / b.r;
      if (a.speed !== 0 && b.speed === 0) { b.speed = sign * a.speed * ratio; changed = true; }
      else if (b.speed !== 0 && a.speed === 0) { a.speed = sign * b.speed / ratio; changed = true; }
    }
  }
}

// --- Draw ---
function drawGear(g) {
  const { cx, cy, r, teeth, variant, angle } = g;
  const s = Math.round(45 + noise(cx * 0.008, cy * 0.008) * 25); // gunmetal 45–70
  const toothH = r * 0.17;
  const innerR = r - toothH;
  const span = (2 * Math.PI) / teeth;

  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(angle);

  // Tooth profile
  ctx.beginPath();
  for (let k = 0; k < teeth; k++) {
    const a0 = k * span;
    const a1 = a0 + span * 0.3;
    const a2 = a0 + span * 0.7;
    const a3 = a0 + span;
    ctx.lineTo(Math.cos(a0) * innerR, Math.sin(a0) * innerR);
    ctx.lineTo(Math.cos(a1) * r,      Math.sin(a1) * r);
    ctx.lineTo(Math.cos(a2) * r,      Math.sin(a2) * r);
    ctx.lineTo(Math.cos(a3) * innerR, Math.sin(a3) * innerR);
  }
  ctx.closePath();

  const bg = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
  bg.addColorStop(0,   `rgb(${s+16},${s+13},${s+9})`);
  bg.addColorStop(0.65,`rgb(${s},${s-3},${s-7})`);
  bg.addColorStop(1,   `rgb(${s-16},${s-20},${s-24})`);
  ctx.fillStyle = bg;
  ctx.fill();
  ctx.strokeStyle = `rgba(${s+42},${s+40},${s+34},0.8)`;
  ctx.lineWidth = 1.2;
  ctx.stroke();

  // Interior
  if (variant === 1) {
    const spokes = Math.max(4, Math.floor(teeth / 5));
    ctx.strokeStyle = `rgba(${s+32},${s+30},${s+24},0.7)`;
    ctx.lineWidth = 1.5;
    for (let k = 0; k < spokes; k++) {
      const a = (k / spokes) * Math.PI * 2;
      ctx.beginPath();
      ctx.moveTo(Math.cos(a) * innerR * 0.2, Math.sin(a) * innerR * 0.2);
      ctx.lineTo(Math.cos(a) * innerR * 0.82, Math.sin(a) * innerR * 0.82);
      ctx.stroke();
    }
  } else if (variant === 2) {
    ctx.beginPath();
    ctx.arc(0, 0, innerR * 0.78, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(${s-8},${s-11},${s-15},0.55)`;
    ctx.fill();
  } else {
    for (let t = 0.3; t < 0.9; t += 0.3) {
      ctx.beginPath();
      ctx.arc(0, 0, innerR * t, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(${s+26},${s+23},${s+18},${0.2 + t * 0.3})`;
      ctx.lineWidth = 0.8;
      ctx.stroke();
    }
  }

  // Hub
  const hubR = innerR * 0.19;
  ctx.beginPath();
  ctx.arc(0, 0, hubR, 0, Math.PI * 2);
  const hg = ctx.createRadialGradient(0, 0, 0, 0, 0, hubR);
  hg.addColorStop(0, `rgb(${s+14},${s+11},${s+7})`);
  hg.addColorStop(1, `rgb(${s-14},${s-17},${s-21})`);
  ctx.fillStyle = hg;
  ctx.fill();
  ctx.strokeStyle = `rgba(${s+36},${s+34},${s+29},0.85)`;
  ctx.lineWidth = 1.2;
  ctx.stroke();

  // Bolt
  ctx.beginPath();
  ctx.arc(0, 0, hubR * 0.33, 0, Math.PI * 2);
  ctx.fillStyle = `rgb(${s+10},${s+8},${s+4})`;
  ctx.fill();

  ctx.restore();
}

function drawChain(a, b, offset) {
  const dx = b.cx - a.cx, dy = b.cy - a.cy;
  const dist = Math.hypot(dx, dy);
  const ang = Math.atan2(dy, dx);
  const dr = b.r - a.r;
  if (Math.abs(dr) >= dist) return;
  const beta = Math.asin(Math.max(-1, Math.min(1, dr / dist)));

  const t1x1 = a.cx + a.r * Math.cos(ang + Math.PI/2 - beta);
  const t1y1 = a.cy + a.r * Math.sin(ang + Math.PI/2 - beta);
  const t1x2 = b.cx + b.r * Math.cos(ang + Math.PI/2 - beta);
  const t1y2 = b.cy + b.r * Math.sin(ang + Math.PI/2 - beta);
  const t2x1 = a.cx + a.r * Math.cos(ang - Math.PI/2 + beta);
  const t2y1 = a.cy + a.r * Math.sin(ang - Math.PI/2 + beta);
  const t2x2 = b.cx + b.r * Math.cos(ang - Math.PI/2 + beta);
  const t2y2 = b.cy + b.r * Math.sin(ang - Math.PI/2 + beta);

  // Walk each strand in pixel-space; first link starts at offset % LINK_SPACING
  const firstPos = ((offset % LINK_SPACING) + LINK_SPACING) % LINK_SPACING;
  for (const [sx, sy, ex, ey] of [
    [t1x1, t1y1, t1x2, t1y2],
    [t2x1, t2y1, t2x2, t2y2]
  ]) {
    const strandLen = Math.hypot(ex - sx, ey - sy);
    const sa = Math.atan2(ey - sy, ex - sx);
    for (let pos = firstPos; pos < strandLen; pos += LINK_SPACING) {
      const t = pos / strandLen;
      ctx.save();
      ctx.translate(sx + (ex - sx) * t, sy + (ey - sy) * t);
      ctx.rotate(sa);
      ctx.strokeStyle = 'rgba(200,190,155,0.75)';
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.ellipse(0, 0, 5, 2.5, 0, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
  }
}

function drawMesh(a, b) {
  ctx.save();
  ctx.setLineDash([3, 6]);
  ctx.strokeStyle = 'rgba(55,52,48,0.18)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(a.cx, a.cy);
  ctx.lineTo(b.cx, b.cy);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();
}

function draw() {
  const bg = ctx.createLinearGradient(0, 0, 0, H);
  bg.addColorStop(0, '#181614');
  bg.addColorStop(1, '#111010');
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, W, H);

  for (const c of chains) {
    if (c.type === 'chain') drawChain(gears[c.i], gears[c.j], c.offset);
    else drawMesh(gears[c.i], gears[c.j]);
  }
  for (const g of gears) drawGear(g);

  // Vignette
  const vig = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W,H)*0.72);
  vig.addColorStop(0, 'rgba(0,0,0,0)');
  vig.addColorStop(1, 'rgba(0,0,0,0.45)');
  ctx.fillStyle = vig;
  ctx.fillRect(0, 0, W, H);
}

const LINK_SPACING = 9; // pixels between chain links

function loop() {
  if (!paused) {
    for (const g of gears) g.angle += g.speed * dir;
    // Advance chain offsets by surface speed of driving gear
    for (const c of chains) {
      if (c.type === 'chain') {
        c.offset = (c.offset + gears[c.i].r * gears[c.i].speed * dir) % LINK_SPACING;
        if (c.offset < 0) c.offset += LINK_SPACING;
      }
    }
    draw();
  }
  requestAnimationFrame(loop);
}

function togglePause() { paused = !paused; }
function reverseDir() { dir *= -1; }

resize();
loop();
</script>
</body>
</html>
