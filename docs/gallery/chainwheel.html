<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+CiAgPHJlY3QgZmlsbD0iIzBhMGEwYSIgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIi8+CiAgPHBhdGggZD0iTTggOCBMMjQgOCBMMjQgMjQgTDggMjQgWiBNMTIgMTIgTDIwIDEyIEwyMCAyMCBMMTIgMjAgWiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjZTBlMGUwIiBzdHJva2Utd2lkdGg9IjEuNSIvPgo8L3N2Zz4K"/>
<title>Chainwheel System</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #1a1612; overflow: hidden; }
canvas { display: block; width: 100vw; height: 100vh; }
.controls {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  display: flex; gap: 12px; background: rgba(0,0,0,0.85);
  padding: 12px 20px; border-radius: 8px;
  font-family: ui-monospace,monospace; color: #888;
  font-size: 13px; align-items: center;
}
button {
  background: #222; color: #888; border: 1px solid #333;
  padding: 6px 14px; border-radius: 4px; cursor: pointer;
  font-family: ui-monospace,monospace; font-size: 13px;
}
button:hover { background: #2a2a2a; color: #aaa; }
.back-btn {
  position: fixed; top: 16px; right: 16px;
  background: rgba(20,20,20,0.9); border: 1px solid #333;
  color: #777; padding: 8px 14px; border-radius: 6px;
  font: 12px ui-monospace,monospace; cursor: pointer;
  text-decoration: none; backdrop-filter: blur(8px);
  z-index: 1000; transition: border-color 0.2s;
}
.back-btn:hover { border-color: #555; color: #aaa; }
</style>
</head>
<body>
<a href="./" class="back-btn">← Gallery</a>
<canvas id="c"></canvas>
<div class="controls">
  <button onclick="togglePause()">Pause</button>
  <button onclick="reverseDir()">Reverse</button>
  <span id="info">Mechanical Assembly</span>
</div>
<script>
// Chainwheel System — monochrome mechanical cascade
// Cycle 1 rebuild (Petrarch) — Quimbot 2026

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const inIframe = window.self !== window.top;
if (inIframe) {
  document.querySelector('.back-btn').style.display = 'none';
  document.querySelector('.controls').style.display = 'none';
}

let W, H;
function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  rebuildSystem();
}
window.addEventListener('resize', resize);
resize();

let paused = false;
let direction = 1;
const baseSpeed = 0.006;

// Noise function for texture
function noise(x, y) {
  const n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
  return n - Math.floor(n);
}

let gearIdx = 0;
function buildGear(x, y, r, teeth, variant) {
  const hue = (gearIdx * 47) % 360; // golden-angle hue spread
  gearIdx++;
  return { x, y, r, teeth, angle: Math.random() * Math.PI * 2, variant, speed: 0, hue };
}

let gears = [];
let chains = [];

function rebuildSystem() {
  gears = [];
  chains = [];
  gearIdx = 0;
  
  const S = Math.min(W, H);
  const cx = W / 2, cy = H / 2;
  
  // Grid-based placement for dense coverage
  const cols = 7, rows = 5;
  const spacingX = W / (cols + 1);
  const spacingY = H / (rows + 1);
  
  let idx = 0;
  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      const x = (col + 1) * spacingX + (Math.random() - 0.5) * spacingX * 0.3;
      const y = (row + 1) * spacingY + (Math.random() - 0.5) * spacingY * 0.3;
      const baseR = S * (0.05 + Math.random() * 0.06);
      const teeth = Math.floor(12 + Math.random() * 20);
      const variant = Math.floor(Math.random() * 3); // 0=standard, 1=spoked, 2=solid
      gears.push(buildGear(x, y, baseR, teeth, variant));
      idx++;
      if (idx >= 35) break;
    }
    if (idx >= 35) break;
  }
  
  // Build chain network — connect nearby gears
  for (let i = 0; i < gears.length; i++) {
    for (let j = i + 1; j < gears.length; j++) {
      const g1 = gears[i], g2 = gears[j];
      const dist = Math.hypot(g2.x - g1.x, g2.y - g1.y);
      const minDist = g1.r + g2.r + 10;
      const maxDist = S * 0.35;
      
      if (dist > minDist && dist < maxDist && Math.random() > 0.6) {
        chains.push({ i, j, type: Math.random() > 0.5 ? 'chain' : 'mesh' });
      }
    }
  }
  
  // Set master gear (largest)
  gears.sort((a, b) => b.r - a.r);
  gears[0].speed = baseSpeed;
  propagateSpeeds();
}

function propagateSpeeds() {
  // Reset all non-master speeds
  for (let i = 1; i < gears.length; i++) gears[i].speed = 0;
  
  // Propagate through chains
  let changed = true;
  let iterations = 0;
  while (changed && iterations < 100) {
    changed = false;
    iterations++;
    for (const { i, j, type } of chains) {
      const g1 = gears[i], g2 = gears[j];
      const ratio = g1.r / g2.r;
      const sign = type === 'chain' ? 1 : -1;
      
      if (g1.speed !== 0 && g2.speed === 0) {
        g2.speed = sign * g1.speed * ratio;
        changed = true;
      } else if (g2.speed !== 0 && g1.speed === 0) {
        g1.speed = sign * g2.speed / ratio;
        changed = true;
      }
    }
  }
}

propagateSpeeds();

function drawGearTooth(r, innerR, a0, toothSpan) {
  const mid = a0 + toothSpan / 2;
  const toothTop = r;
  const toothBase = innerR;
  
  ctx.lineTo(Math.cos(a0) * toothBase, Math.sin(a0) * toothBase);
  ctx.lineTo(Math.cos(a0 + toothSpan * 0.1) * toothTop, Math.sin(a0 + toothSpan * 0.1) * toothTop);
  ctx.lineTo(Math.cos(mid) * (toothTop + 2), Math.sin(mid) * (toothTop + 2));
  ctx.lineTo(Math.cos(a0 + toothSpan * 0.9) * toothTop, Math.sin(a0 + toothSpan * 0.9) * toothTop);
  ctx.lineTo(Math.cos(a0 + toothSpan) * toothBase, Math.sin(a0 + toothSpan) * toothBase);
}

function drawGear(g) {
  const { x, y, r, teeth, angle, variant, hue } = g;
  const toothHeight = r * 0.18;
  const innerR = r - toothHeight;
  const toothSpan = (2 * Math.PI / teeth);
  
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  
  // Gear body with teeth
  ctx.beginPath();
  for (let i = 0; i < teeth; i++) {
    const a0 = i * toothSpan;
    drawGearTooth(r, innerR, a0, toothSpan);
  }
  ctx.closePath();
  
  // Glow
  const glow = ctx.createRadialGradient(0, 0, innerR * 0.5, 0, 0, r * 1.6);
  glow.addColorStop(0, `hsla(${hue},90%,55%,0.25)`);
  glow.addColorStop(1, `hsla(${hue},90%,40%,0)`);
  ctx.beginPath();
  ctx.arc(0, 0, r * 1.8, 0, Math.PI * 2);
  ctx.fillStyle = glow;
  ctx.fill();

  // Gear body gradient
  const bodyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
  bodyGrad.addColorStop(0, `hsl(${hue},75%,48%)`);
  bodyGrad.addColorStop(0.6, `hsl(${hue},80%,32%)`);
  bodyGrad.addColorStop(1, `hsl(${hue},85%,18%)`);
  ctx.fillStyle = bodyGrad;
  ctx.fill();

  // Edge highlight
  ctx.strokeStyle = `hsl(${hue},100%,72%)`;
  ctx.lineWidth = 2;
  ctx.stroke();

  // Interior details based on variant
  if (variant === 1) {
    // Spoked wheel
    const spokeCount = Math.max(4, Math.floor(teeth / 5));
    ctx.strokeStyle = `hsl(${hue},90%,70%)`;
    ctx.lineWidth = 2;
    for (let i = 0; i < spokeCount; i++) {
      const a = (i / spokeCount) * Math.PI * 2;
      ctx.beginPath();
      ctx.moveTo(Math.cos(a) * innerR * 0.2, Math.sin(a) * innerR * 0.2);
      ctx.lineTo(Math.cos(a) * innerR * 0.85, Math.sin(a) * innerR * 0.85);
      ctx.stroke();
    }
  } else if (variant === 2) {
    // Solid disc
    ctx.fillStyle = `hsla(${hue},70%,20%,0.7)`;
    ctx.beginPath();
    ctx.arc(0, 0, innerR * 0.8, 0, Math.PI * 2);
    ctx.fill();
  } else {
    // Standard — concentric rings
    for (let ring = 0.3; ring < 0.9; ring += 0.25) {
      ctx.strokeStyle = `hsla(${hue},80%,65%,${0.2 + ring * 0.3})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(0, 0, innerR * ring, 0, Math.PI * 2);
      ctx.stroke();
    }
  }

  // Central hub
  const hubR = innerR * 0.18;
  ctx.beginPath();
  ctx.arc(0, 0, hubR, 0, Math.PI * 2);
  const hubGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, hubR);
  hubGrad.addColorStop(0, `hsl(${hue},60%,55%)`);
  hubGrad.addColorStop(1, `hsl(${hue},70%,25%)`);
  ctx.fillStyle = hubGrad;
  ctx.fill();
  ctx.strokeStyle = `hsl(${hue},100%,75%)`;
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Axle bolt
  ctx.beginPath();
  ctx.arc(0, 0, hubR * 0.35, 0, Math.PI * 2);
  ctx.fillStyle = `hsl(${hue},80%,85%)`;
  ctx.fill();
  ctx.strokeStyle = `hsl(${hue},90%,90%)`;
  ctx.lineWidth = 1;
  ctx.stroke();
  
  ctx.restore();
}

function drawChainLink(x, y, angle, size) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  
  // Outer link
  ctx.strokeStyle = 'rgba(210, 200, 160, 0.8)';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.ellipse(0, 0, size * 1.8, size * 0.9, 0, 0, Math.PI * 2);
  ctx.stroke();

  // Inner highlight
  ctx.strokeStyle = 'rgba(255, 240, 180, 0.5)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.ellipse(0, 0, size * 1.3, size * 0.6, 0, 0, Math.PI * 2);
  ctx.stroke();
  
  ctx.restore();
}

function drawChain(g1, g2) {
  const dx = g2.x - g1.x, dy = g2.y - g1.y;
  const dist = Math.hypot(dx, dy);
  const angle = Math.atan2(dy, dx);
  const r1 = g1.r, r2 = g2.r;
  
  // Tangent calculation
  const dr = r2 - r1;
  if (Math.abs(dr) >= dist) return;
  
  const alpha = Math.atan2(dr, dist);
  const beta = Math.asin(dr / dist);
  
  // Top tangent line
  const t1x1 = g1.x + r1 * Math.cos(angle + Math.PI / 2 - beta);
  const t1y1 = g1.y + r1 * Math.sin(angle + Math.PI / 2 - beta);
  const t1x2 = g2.x + r2 * Math.cos(angle + Math.PI / 2 - beta);
  const t1y2 = g2.y + r2 * Math.sin(angle + Math.PI / 2 - beta);
  
  // Bottom tangent line
  const t2x1 = g1.x + r1 * Math.cos(angle - Math.PI / 2 + beta);
  const t2y1 = g1.y + r1 * Math.sin(angle - Math.PI / 2 + beta);
  const t2x2 = g2.x + r2 * Math.cos(angle - Math.PI / 2 + beta);
  const t2y2 = g2.y + r2 * Math.sin(angle - Math.PI / 2 + beta);
  
  // Draw chain links along both strands
  const linkCount = Math.floor(dist / 8);
  const linkSize = 3;
  
  for (let i = 0; i <= linkCount; i++) {
    const t = i / linkCount;
    const x1 = t1x1 + (t1x2 - t1x1) * t;
    const y1 = t1y1 + (t1y2 - t1y1) * t;
    const x2 = t2x1 + (t2x2 - t2x1) * t;
    const y2 = t2y1 + (t2y2 - t2y1) * t;
    
    drawChainLink(x1, y1, angle, linkSize);
    drawChainLink(x2, y2, angle, linkSize);
  }
}

function drawMesh(g1, g2) {
  // Meshed gears — subtle connection line
  ctx.save();
  ctx.strokeStyle = 'rgba(60, 55, 50, 0.15)';
  ctx.lineWidth = 1;
  ctx.setLineDash([3, 5]);
  ctx.beginPath();
  ctx.moveTo(g1.x, g1.y);
  ctx.lineTo(g2.x, g2.y);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();
}

function update() {
  for (const g of gears) {
    g.angle += g.speed * direction;
  }
}

function draw() {
  // Barren landscape background
  const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
  bgGrad.addColorStop(0, '#1a1612');
  bgGrad.addColorStop(1, '#121010');
  ctx.fillStyle = bgGrad;
  ctx.fillRect(0, 0, W, H);
  
  // Draw chains first (background layer)
  for (const { i, j, type } of chains) {
    if (type === 'chain') drawChain(gears[i], gears[j]);
    else drawMesh(gears[i], gears[j]);
  }
  
  // Draw gears (foreground)
  for (const g of gears) drawGear(g);
  
  // Subtle vignette
  const vignette = ctx.createRadialGradient(W / 2, H / 2, 0, W / 2, H / 2, Math.max(W, H) * 0.7);
  vignette.addColorStop(0, 'rgba(0,0,0,0)');
  vignette.addColorStop(1, 'rgba(0,0,0,0.5)');
  ctx.fillStyle = vignette;
  ctx.fillRect(0, 0, W, H);
  
  if (!inIframe) {
    ctx.fillStyle = '#444';
    ctx.font = '11px ui-monospace,monospace';
    ctx.fillText(`${gears.length} gears · ${chains.length} connections`, 20, H - 20);
  }
}

function loop() {
  if (!paused) { update(); draw(); }
  requestAnimationFrame(loop);
}

function togglePause() { paused = !paused; }
function reverseDir() { direction *= -1; }

loop();
</script>
</body>
</html>
