<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Clifford Attractor</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{height:100%;background:#050508;overflow:hidden;display:flex;flex-direction:column}
canvas{display:block;flex:1;width:100%;touch-action:none}
.back{position:fixed;top:1rem;left:1rem;font:0.8rem/1 ui-monospace,SFMono-Regular,Menlo,monospace;color:#aaa;background:rgba(5,5,8,0.88);padding:0.5rem 0.8rem;border-radius:4px;text-decoration:none;border:1px solid #333;z-index:10;transition:border-color 0.2s}
.back:hover{border-color:#666;color:#fff}
.panel{background:#0a0a10;border-top:1px solid #1a1a28;padding:0.65rem 0.9rem;display:flex;justify-content:space-between;align-items:center;gap:0.75rem;font:0.75rem/1 ui-monospace,SFMono-Regular,Menlo,monospace;flex-wrap:wrap;flex-shrink:0}
.panel .meta{display:flex;align-items:center;gap:0.6rem;color:#a070d4}
.panel .hint{color:#4a3565}
.panel .params{display:flex;align-items:center;gap:0.4rem;color:#7855aa;font-size:0.7rem}
.panel .controls{display:flex;align-items:center;gap:0.55rem;flex-wrap:wrap}
.panel button{background:rgba(255,255,255,0.05);border:1px solid #2a204a;color:#9070c4;font:0.75rem ui-monospace,SFMono-Regular,Menlo,monospace;padding:8px 14px;border-radius:4px;cursor:pointer;transition:all 0.2s;-webkit-tap-highlight-color:transparent}
.panel button:hover{background:rgba(255,255,255,0.1);color:#c0a0f0;border-color:#5a408a}
.in-iframe .back,.in-iframe .panel{display:none}
@media(max-width:760px){.panel{padding:0.5rem}.panel .params{font-size:0.65rem}}
</style>
</head>
<body>
<a class="back" href="../gallery/">← gallery</a>
<canvas id="c"></canvas>
<div class="panel">
  <div class="meta">
    <span>Clifford Attractor</span>
    <span class="hint">x' = sin(ay) + c·cos(ax) &nbsp;|&nbsp; y' = sin(bx) + d·cos(by)</span>
  </div>
  <div class="controls">
    <span class="params" id="paramDisplay">a=? b=? c=? d=?</span>
    <button id="morphBtn">morph</button>
    <button id="randomBtn">random</button>
  </div>
</div>
<script>
if(window.self!==window.top) document.documentElement.classList.add('in-iframe');

const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');

let W=0,H=0;
let buf=null;

const PRESETS=[
  [-1.4, 1.6, 1.0, 0.7],
  [-1.7, 1.8,-1.9,-0.4],
  [ 1.5,-1.8, 1.6, 0.9],
  [-1.8,-2.0,-0.5,-0.9],
  [ 2.0,-2.0, 0.5, 0.9],
  [-1.3, 1.7,-1.5,-0.8],
  [ 0.7, 1.5,-1.4, 2.0],
  [-1.0, 1.0, 1.8,-2.0],
  [ 1.6,-0.6,-1.2, 1.6],
  [-1.9, 0.8,-0.6,-1.0],
];

let pa,pb,pc,pd;
let targetA,targetB,targetC,targetD;
let morphing=false;
let presetIdx=0;

function setParams(a,b,c,d){
  pa=a; pb=b; pc=c; pd=d;
  updateDisplay();
}

function updateDisplay(){
  document.getElementById('paramDisplay').textContent=
    'a='+pa.toFixed(2)+' b='+pb.toFixed(2)+' c='+pc.toFixed(2)+' d='+pd.toFixed(2);
}

setParams(...PRESETS[0]);

// Compute bounds by running the attractor briefly
function computeBounds(a,b,c,d,n){
  n=n||40000;
  let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
  let x=0.1,y=0.1;
  for(let i=0;i<n;i++){
    const nx=Math.sin(a*y)+c*Math.cos(a*x);
    const ny=Math.sin(b*x)+d*Math.cos(b*y);
    x=nx; y=ny;
    if(i>200){
      if(x<minX) minX=x;
      if(x>maxX) maxX=x;
      if(y<minY) minY=y;
      if(y>maxY) maxY=y;
    }
  }
  // Fallback if degenerate
  if(!isFinite(minX)||maxX-minX<0.01){minX=-3;maxX=3;}
  if(!isFinite(minY)||maxY-minY<0.01){minY=-3;maxY=3;}
  return{minX:minX,maxX:maxX,minY:minY,maxY:maxY};
}

let bounds={minX:-3,maxX:3,minY:-3,maxY:3};

// Rendering state
const N_TOTAL=800000;
const BATCH=50000;
let iterX=0.1,iterY=0.1;
let iterCount=0;
let rendering=false;

function fullReset(){
  if(W<1||H<1) return;
  buf=new Float32Array(W*H);
  bounds=computeBounds(pa,pb,pc,pd);
  iterX=0.1; iterY=0.1; iterCount=0;
  rendering=true;
}

function resize(){
  const nw=canvas.offsetWidth;
  const nh=canvas.offsetHeight;
  if(nw<1||nh<1) return false;
  if(nw===W&&nh===H) return false;
  W=nw; H=nh;
  canvas.width=W;
  canvas.height=H;
  fullReset();
  return true;
}

function runBatch(){
  if(!rendering||!buf||W<1||H<1) return;

  const a=pa,b=pb,c=pc,d=pd;
  var bnd=bounds;
  var rangeX=bnd.maxX-bnd.minX;
  var rangeY=bnd.maxY-bnd.minY;
  var pad=0.08;
  var sX=(W*(1-2*pad))/rangeX;
  var sY=(H*(1-2*pad))/rangeY;
  var oX=W*pad-bnd.minX*sX;
  var oY=H*pad-bnd.minY*sY;

  var count=Math.min(BATCH,N_TOTAL-iterCount);
  var x=iterX,y=iterY;

  for(var i=0;i<count;i++){
    var nx=Math.sin(a*y)+c*Math.cos(a*x);
    var ny=Math.sin(b*x)+d*Math.cos(b*y);
    x=nx; y=ny;
    if(iterCount+i>200){
      var px=(x*sX+oX)|0;
      var py=(y*sY+oY)|0;
      if(px>=0&&px<W&&py>=0&&py<H){
        buf[py*W+px]++;
      }
    }
  }
  iterX=x; iterY=y;
  iterCount+=count;

  // Find max density for normalization
  var gmax=0;
  for(var j=0;j<buf.length;j++){
    if(buf[j]>gmax) gmax=buf[j];
  }

  // Render density to canvas
  var imgData=ctx.createImageData(W,H);
  var d8=imgData.data;
  var logMax=Math.log(gmax+1);

  for(var j=0;j<buf.length;j++){
    var off=j*4;
    if(buf[j]===0){
      d8[off]=5; d8[off+1]=5; d8[off+2]=8; d8[off+3]=255;
    } else {
      var v=Math.log(buf[j]+1)/logMax;
      // purple -> pink -> white
      d8[off]=Math.min(255,(v*v*255+v*80)|0);
      d8[off+1]=Math.min(255,(v*v*140)|0);
      d8[off+2]=Math.min(255,(v*220+v*v*35)|0);
      d8[off+3]=255;
    }
  }
  ctx.putImageData(imgData,0,0);

  if(iterCount>=N_TOTAL) rendering=false;
}

function loop(){
  resize();

  // Morph: interpolate params toward target
  if(morphing){
    var done=true;
    var rate=0.06;
    function step(cur,tgt){
      if(Math.abs(cur-tgt)<0.001) return tgt;
      done=false;
      return cur+(tgt-cur)*rate;
    }
    pa=step(pa,targetA);
    pb=step(pb,targetB);
    pc=step(pc,targetC);
    pd=step(pd,targetD);
    updateDisplay();

    if(done){
      morphing=false;
      pa=targetA; pb=targetB; pc=targetC; pd=targetD;
    }
    // Re-render from scratch each morph frame
    if(W>0&&H>0){
      buf.fill(0);
      bounds=computeBounds(pa,pb,pc,pd,15000);
      iterX=0.1; iterY=0.1; iterCount=0;
      rendering=true;
    }
  }

  runBatch();
  requestAnimationFrame(loop);
}

// Wait for layout so offsetWidth/Height are real
requestAnimationFrame(function(){
  requestAnimationFrame(loop);
});

document.getElementById('morphBtn').addEventListener('click',function(){
  presetIdx=(presetIdx+1)%PRESETS.length;
  targetA=PRESETS[presetIdx][0];
  targetB=PRESETS[presetIdx][1];
  targetC=PRESETS[presetIdx][2];
  targetD=PRESETS[presetIdx][3];
  morphing=true;
});

document.getElementById('randomBtn').addEventListener('click',function(){
  targetA=-2+Math.random()*4;
  targetB=-2+Math.random()*4;
  targetC=-2+Math.random()*4;
  targetD=-2+Math.random()*4;
  morphing=true;
  presetIdx=-1;
});
</script>
</body>
</html>
