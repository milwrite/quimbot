<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Clifford Attractor</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{height:100%;background:#050508;overflow:hidden;display:flex;flex-direction:column}
canvas{display:block;flex:1;width:100%;touch-action:none}
.back{position:fixed;top:1rem;left:1rem;font:0.8rem/1 ui-monospace,SFMono-Regular,Menlo,monospace;color:#aaa;background:rgba(5,5,8,0.88);padding:0.5rem 0.8rem;border-radius:4px;text-decoration:none;border:1px solid #333;z-index:10;transition:border-color 0.2s}
.back:hover{border-color:#666;color:#fff}
.panel{background:#0a0a10;border-top:1px solid #1a1a28;padding:0.65rem 0.9rem;display:flex;justify-content:space-between;align-items:center;gap:0.75rem;font:0.75rem/1 ui-monospace,SFMono-Regular,Menlo,monospace;flex-wrap:wrap;flex-shrink:0}
.panel .meta{display:flex;align-items:center;gap:0.6rem;color:#a070d4}
.panel .hint{color:#4a3565}
.panel .params{display:flex;align-items:center;gap:0.4rem;color:#7855aa;font-size:0.7rem}
.panel .controls{display:flex;align-items:center;gap:0.55rem;flex-wrap:wrap}
.panel button{background:rgba(255,255,255,0.05);border:1px solid #2a204a;color:#9070c4;font:0.75rem ui-monospace,SFMono-Regular,Menlo,monospace;padding:8px 14px;border-radius:4px;cursor:pointer;transition:all 0.2s;-webkit-tap-highlight-color:transparent}
.panel button:hover{background:rgba(255,255,255,0.1);color:#c0a0f0;border-color:#5a408a}
.in-iframe .back,.in-iframe .panel{display:none}
@media(max-width:760px){.panel{padding:0.5rem}.panel .params{font-size:0.65rem}}
</style>
</head>
<body>
<a class="back" href="../gallery/">← gallery</a>
<canvas id="c"></canvas>
<div class="panel">
  <div class="meta">
    <span>Clifford Attractor</span>
    <span class="hint">x' = sin(ay) + c·cos(ax) &nbsp;|&nbsp; y' = sin(bx) + d·cos(by)</span>
  </div>
  <div class="controls">
    <span class="params" id="paramDisplay">a=? b=? c=? d=?</span>
    <button id="morphBtn">morph</button>
    <button id="randomBtn">random</button>
  </div>
</div>
<script>
if(window.self!==window.top) document.documentElement.classList.add('in-iframe');

const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');

let W,H;
// Density buffer
let buf,density;

// Attractor parameters
const PRESETS=[
  [-1.4, 1.6, 1.0, 0.7],
  [-1.7, 1.8,-1.9,-0.4],
  [ 1.5,-1.8, 1.6, 0.9],
  [-1.8,-2.0,-0.5,-0.9],
  [ 2.0,-2.0, 0.5, 0.9],
  [-1.3, 1.7,-1.5,-0.8],
  [ 0.7, 1.5,-1.4, 2.0],
  [-1.0, 1.0, 1.8,-2.0],
  [ 1.6,-0.6,-1.2, 1.6],
  [-1.9, 0.8,-0.6,-1.0],
];

let pa,pb,pc,pd;
let targetA,targetB,targetC,targetD;
let morphT=1; // 0=start morph, 1=done
let presetIdx=0;

function setParams(a,b,c,d){
  pa=a; pb=b; pc=c; pd=d;
  updateParamDisplay();
}

function updateParamDisplay(){
  document.getElementById('paramDisplay').textContent=
    `a=${pa.toFixed(2)} b=${pb.toFixed(2)} c=${pc.toFixed(2)} d=${pd.toFixed(2)}`;
}

function startMorph(a,b,c,d){
  targetA=a; targetB=b; targetC=c; targetD=d;
  morphT=0;
}

// Initialize with first preset
setParams(...PRESETS[0]);

function resize(){
  W=canvas.offsetWidth;
  H=canvas.offsetHeight;
  canvas.width=W;
  canvas.height=H;
  buf=new Float32Array(W*H);
  density=new Float32Array(W*H);
  redraw();
}
window.addEventListener('resize',()=>{resize();});
resize();

// Compute attractor bounds for current params
function computeBounds(a,b,c,d,samples=50000){
  let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
  let x=0,y=0;
  for(let i=0;i<samples;i++){
    const nx=Math.sin(a*y)+c*Math.cos(a*x);
    const ny=Math.sin(b*x)+d*Math.cos(b*y);
    x=nx; y=ny;
    if(i>100){
      if(x<minX)minX=x; if(x>maxX)maxX=x;
      if(y<minY)minY=y; if(y>maxY)maxY=y;
    }
  }
  return{minX,maxX,minY,maxY};
}

let bounds={minX:-3,maxX:3,minY:-3,maxY:3};

function redraw(){
  buf.fill(0);
  density.fill(0);
  bounds=computeBounds(pa,pb,pc,pd);
}

const N_ITER=800000; // points per frame batch (spread over frames)
const BATCH=40000;
let batchX=0,batchY=0;
let iterCount=0;
let rendering=false;

function startRender(){
  batchX=0; batchY=0; iterCount=0;
  buf.fill(0);
  density.fill(0);
  rendering=true;
}

startRender();

function runBatch(){
  if(!rendering) return;
  const a=pa,b=pb,c=pc,d=pd;
  const{minX,maxX,minY,maxY}=bounds;
  const rangeX=maxX-minX,rangeY=maxY-minY;
  const pad=0.08;
  const scaleX=(W*(1-2*pad))/rangeX;
  const scaleY=(H*(1-2*pad))/rangeY;
  const offX=W*pad-minX*scaleX;
  const offY=H*pad-minY*scaleY;

  const limit=Math.min(BATCH,N_ITER-iterCount);
  let x=batchX,y=batchY;
  let maxD=0;

  for(let i=0;i<limit;i++){
    const nx=Math.sin(a*y)+c*Math.cos(a*x);
    const ny=Math.sin(b*x)+d*Math.cos(b*y);
    x=nx; y=ny;

    if(iterCount>100){
      const px=Math.floor(x*scaleX+offX);
      const py=Math.floor(y*scaleY+offY);
      if(px>=0&&px<W&&py>=0&&py<H){
        const idx=py*W+px;
        buf[idx]++;
        if(buf[idx]>maxD) maxD=buf[idx];
      }
    }
    iterCount++;
  }

  batchX=x; batchY=y;

  // Find global max for normalization
  let gmax=0;
  for(let i=0;i<buf.length;i++) if(buf[i]>gmax) gmax=buf[i];

  // Render to canvas
  const imgData=ctx.createImageData(W,H);
  const d2=imgData.data;
  for(let i=0;i<buf.length;i++){
    if(buf[i]===0){
      d2[i*4]=5; d2[i*4+1]=5; d2[i*4+2]=8; d2[i*4+3]=255;
    } else {
      // Log scale density
      const v=Math.log(buf[i]+1)/Math.log(gmax+1);
      // Purple-pink-white gradient
      const r=Math.round(v*v*255+v*80);
      const g=Math.round(v*v*120);
      const b=Math.round(v*220+v*v*35);
      d2[i*4]=Math.min(255,r);
      d2[i*4+1]=Math.min(255,g);
      d2[i*4+2]=Math.min(255,b);
      d2[i*4+3]=255;
    }
  }
  ctx.putImageData(imgData,0,0);

  if(iterCount>=N_ITER) rendering=false;
}

// Morph between parameter sets smoothly
function easeInOut(t){return t<0.5?2*t*t:1-Math.pow(-2*t+2,2)/2;}

let frame=0;
function loop(){
  // Handle morph
  if(morphT<1){
    morphT=Math.min(1,morphT+0.015);
    const e=easeInOut(morphT);
    pa=pa+(targetA-pa)*0.05;
    pb=pb+(targetB-pb)*0.05;
    pc=pc+(targetC-pc)*0.05;
    pd=pd+(targetD-pd)*0.05;
    updateParamDisplay();
    bounds=computeBounds(pa,pb,pc,pd,20000);
    buf.fill(0);
    batchX=0; batchY=0; iterCount=0;
    rendering=true;
  }

  runBatch();
  frame++;
  requestAnimationFrame(loop);
}
loop();

document.getElementById('morphBtn').addEventListener('click',()=>{
  presetIdx=(presetIdx+1)%PRESETS.length;
  startMorph(...PRESETS[presetIdx]);
});

document.getElementById('randomBtn').addEventListener('click',()=>{
  // Random params in range that tend to produce interesting attractors
  const rp=()=>(Math.random()*3-1.5);
  // Bias toward values that work well: mostly [-2, 2]
  const a=-2+Math.random()*4;
  const b=-2+Math.random()*4;
  const c=-2+Math.random()*4;
  const d=-2+Math.random()*4;
  startMorph(a,b,c,d);
  presetIdx=-1;
});
</script>
</body>
</html>
