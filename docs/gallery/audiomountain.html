<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Audio Mountain</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{height:100%;background:#05070d;overflow:hidden;display:flex;flex-direction:column}
canvas{display:block;flex:1;width:100%;touch-action:none}
.back{position:fixed;top:1rem;left:1rem;font:0.8rem/1 ui-monospace,SFMono-Regular,Menlo,monospace;color:#aaa;background:rgba(10,10,10,0.85);padding:0.5rem 0.8rem;border-radius:4px;text-decoration:none;border:1px solid #333;z-index:10;transition:border-color 0.2s}
.back:hover{border-color:#666;color:#fff}
.panel{background:#10131a;border-top:1px solid #232b37;padding:0.65rem 0.9rem;display:flex;justify-content:space-between;align-items:center;gap:0.75rem;font:0.75rem/1 ui-monospace,SFMono-Regular,Menlo,monospace;flex-wrap:wrap;flex-shrink:0}
.panel .left{display:flex;align-items:center;gap:0.6rem;color:#c2d1df}
.panel .mode{color:#80d0ff}
.panel .hint{color:#66788b}
.panel .controls{display:flex;align-items:center;gap:0.55rem;flex-wrap:wrap}
.panel label{display:flex;align-items:center;gap:0.35rem;color:#9bb2c8}
.panel input[type=range]{width:104px;height:30px}
.panel button{background:rgba(255,255,255,0.06);border:1px solid #3a4759;color:#b6c8db;font:0.75rem ui-monospace,SFMono-Regular,Menlo,monospace;padding:8px 14px;border-radius:4px;cursor:pointer;transition:all 0.2s;-webkit-tap-highlight-color:transparent}
.panel button:hover{background:rgba(255,255,255,0.12);color:#fff;border-color:#667a92}
.in-iframe .back,.in-iframe .panel{display:none}
@media (max-width:820px){
  .panel{padding:0.65rem}
  .panel .left{width:100%;justify-content:space-between}
  .panel .hint{font-size:0.68rem}
  .panel .controls{width:100%;justify-content:space-between}
  .panel input[type=range]{width:90px}
}
</style>
</head>
<body>
<script>if(window.self!==window.top)document.body.classList.add('in-iframe');</script>
<a class="back" href="index.html">‚Üê Gallery</a>
<canvas id="c"></canvas>
<div class="panel">
  <div class="left">
    <span id="level">lvl 0.00</span>
    <span class="mode" id="mode">mode: synth fallback</span>
    <span class="hint">drag x/y to adjust</span>
  </div>
  <div class="controls">
    <button id="enableAudio">enable audio</button>
    <label>gain <input id="gain" type="range" min="0.35" max="2.4" step="0.01" value="1.1"><span id="gainVal">1.10</span></label>
    <label>rough <input id="rough" type="range" min="0.25" max="2.2" step="0.01" value="0.95"><span id="roughVal">0.95</span></label>
  </div>
</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });

const levelEl = document.getElementById('level');
const modeEl = document.getElementById('mode');
const enableAudioBtn = document.getElementById('enableAudio');
const gainInput = document.getElementById('gain');
const roughInput = document.getElementById('rough');
const gainValEl = document.getElementById('gainVal');
const roughValEl = document.getElementById('roughVal');

const TAU = Math.PI * 2;
const BIN_COUNT = 96;
const bins = new Float32Array(BIN_COUNT);
const smoothBins = new Float32Array(BIN_COUNT);
const peaks = new Float32Array(BIN_COUNT);

let W = 1;
let H = 1;
let DPR = 1;
let pseudoSeed = Math.random() * 1000;
let gain = 1.1;
let roughness = 0.95;
let analyserActive = false;
let audioMode = 'synth fallback';

let audioCtx = null;
let analyser = null;
let freqBytes = null;
let silentGain = null;
let micStream = null;
let micSource = null;
let synthNodes = [];

const stars = [];

function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

function syncControls() {
  gainInput.value = gain.toFixed(2);
  roughInput.value = roughness.toFixed(2);
  gainValEl.textContent = gain.toFixed(2);
  roughValEl.textContent = roughness.toFixed(2);
}

function setMode(text) {
  audioMode = text;
  modeEl.textContent = `mode: ${text}`;
}

function resize() {
  DPR = Math.min(2, window.devicePixelRatio || 1);
  const rect = canvas.getBoundingClientRect();
  W = Math.max(1, Math.round(rect.width));
  H = Math.max(1, Math.round(rect.height));
  const nextWidth = Math.round(W * DPR);
  const nextHeight = Math.round(H * DPR);
  if (canvas.width !== nextWidth || canvas.height !== nextHeight) {
    canvas.width = nextWidth;
    canvas.height = nextHeight;
  }
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  buildStars();
}

function buildStars() {
  stars.length = 0;
  const count = Math.min(130, Math.max(40, Math.round((W * H) / 18000)));
  for (let i = 0; i < count; i++) {
    stars.push({
      x: Math.random(),
      y: Math.random() * 0.62,
      size: 0.7 + Math.random() * 1.6,
      tw: 0.4 + Math.random() * 2.2,
      phase: Math.random() * TAU,
      alpha: 0.12 + Math.random() * 0.35
    });
  }
}

function stopSynthNodes() {
  for (const node of synthNodes) {
    try { node.osc.stop(); } catch (err) {}
    try { node.osc.disconnect(); } catch (err) {}
    try { node.gain.disconnect(); } catch (err) {}
  }
  synthNodes.length = 0;
}

function disconnectInputNodes() {
  if (micSource) {
    try { micSource.disconnect(); } catch (err) {}
    micSource = null;
  }
  stopSynthNodes();
}

function createSynthAnalyserInput() {
  disconnectInputNodes();
  if (!audioCtx || !analyser) return;
  const freqs = [46, 71, 108, 166, 248, 372];
  synthNodes = freqs.map((base, i) => {
    const osc = audioCtx.createOscillator();
    osc.type = i % 2 === 0 ? 'triangle' : 'sawtooth';
    osc.frequency.value = base;
    const g = audioCtx.createGain();
    g.gain.value = 0.008 + i * 0.0015;
    osc.connect(g);
    g.connect(analyser);
    osc.start();
    return { osc, gain: g, base, phase: Math.random() * TAU };
  });
}

async function enableAudio() {
  const AudioCtor = window.AudioContext || window.webkitAudioContext;
  if (!AudioCtor) {
    analyserActive = false;
    setMode('synth fallback');
    enableAudioBtn.textContent = 'audio unavailable';
    return;
  }

  if (!audioCtx) audioCtx = new AudioCtor();
  if (audioCtx.state === 'suspended') {
    try { await audioCtx.resume(); } catch (err) {}
  }

  if (!analyser) {
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 512;
    analyser.smoothingTimeConstant = 0.8;
    freqBytes = new Uint8Array(analyser.frequencyBinCount);
    silentGain = audioCtx.createGain();
    silentGain.gain.value = 0;
    analyser.connect(silentGain);
    silentGain.connect(audioCtx.destination);
  }

  disconnectInputNodes();
  if (micStream) {
    micStream.getTracks().forEach(track => track.stop());
    micStream = null;
  }

  try {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      throw new Error('media devices unavailable');
    }
    micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    micSource = audioCtx.createMediaStreamSource(micStream);
    micSource.connect(analyser);
    analyserActive = true;
    setMode('mic analyser');
    enableAudioBtn.textContent = 'mic active';
  } catch (err) {
    createSynthAnalyserInput();
    analyserActive = synthNodes.length > 0;
    setMode(analyserActive ? 'webaudio synth' : 'synth fallback');
    enableAudioBtn.textContent = analyserActive ? 'audio active' : 'enable audio';
  }
}

function fillPseudoBins(timeSec) {
  const beat = 0.55 + 0.45 * Math.sin(timeSec * 1.7);
  const kick = Math.max(0, Math.sin(timeSec * 3.3));
  for (let i = 0; i < BIN_COUNT; i++) {
    const f = i / (BIN_COUNT - 1);
    const bass = Math.exp(-Math.pow((f - 0.08) * 14, 2)) * (0.3 + 0.7 * kick);
    const drone = 0.5 + 0.5 * Math.sin(timeSec * (0.8 + f * 3.4) + f * 13 + pseudoSeed);
    const shimmer = 0.5 + 0.5 * Math.sin(timeSec * (5 + f * 14) + f * 40);
    const flutter = Math.sin(timeSec * 15 + f * 90 + pseudoSeed * 0.4) * 0.08;
    const value = (0.18 + drone * 0.38 + shimmer * 0.24 + bass) * (0.65 + beat * 0.45) + flutter;
    bins[i] = clamp(value, 0, 1);
  }
}

function modulateSynth(timeSec) {
  if (!audioCtx || audioMode !== 'webaudio synth' || synthNodes.length === 0) return;
  const now = audioCtx.currentTime;
  for (let i = 0; i < synthNodes.length; i++) {
    const node = synthNodes[i];
    const wobble = 1 + 0.12 * Math.sin(timeSec * (0.7 + i * 0.18) + node.phase);
    const pulse = 0.007 + 0.01 * (0.5 + 0.5 * Math.sin(timeSec * (1.4 + i * 0.22) + node.phase * 1.7));
    node.osc.frequency.setTargetAtTime(node.base * wobble, now, 0.08);
    node.gain.gain.setTargetAtTime(pulse, now, 0.09);
  }
}

function fillAnalyserBins() {
  if (!analyser || !freqBytes) return false;
  analyser.getByteFrequencyData(freqBytes);
  const n = freqBytes.length;
  if (!n) return false;
  for (let i = 0; i < BIN_COUNT; i++) {
    const pct = i / (BIN_COUNT - 1);
    const src = Math.floor(Math.pow(pct, 1.75) * (n - 1));
    bins[i] = freqBytes[src] / 255;
  }
  return true;
}

function smoothSpectrum() {
  for (let i = 0; i < BIN_COUNT; i++) {
    smoothBins[i] += (bins[i] - smoothBins[i]) * 0.16;
    peaks[i] = Math.max(peaks[i] * 0.994, smoothBins[i]);
  }
}

function averageBand(start, end) {
  let sum = 0;
  const hi = Math.min(BIN_COUNT, end);
  for (let i = start; i < hi; i++) sum += smoothBins[i];
  return sum / Math.max(1, hi - start);
}

function drawSky(timeSec, low, mid, high) {
  const topHue = 205 + high * 35;
  const horizonHue = 215 + mid * 26;
  const g = ctx.createLinearGradient(0, 0, 0, H);
  g.addColorStop(0, `hsl(${topHue},46%,${7 + low * 6}%)`);
  g.addColorStop(0.55, `hsl(${horizonHue},34%,${9 + mid * 8}%)`);
  g.addColorStop(1, '#05060a');
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, W, H);

  for (let i = 0; i < stars.length; i++) {
    const s = stars[i];
    const alpha = clamp(s.alpha + Math.sin(timeSec * s.tw + s.phase) * 0.2, 0.05, 0.9);
    ctx.fillStyle = `rgba(180,220,255,${alpha * (0.65 + high * 0.8)})`;
    const px = s.x * W;
    const py = s.y * H;
    ctx.fillRect(px, py, s.size, s.size);
  }

  ctx.fillStyle = `rgba(75,110,170,${0.05 + high * 0.1})`;
  ctx.fillRect(0, H * 0.58, W, H * 0.2);
}

function drawMountains(timeSec, low, mid) {
  const layers = W < 720 ? 5 : 6;
  const xStep = Math.max(4, Math.round(W / 150));

  for (let layer = 0; layer < layers; layer++) {
    const depth = layer / Math.max(1, layers - 1);
    const baseY = H * (0.34 + depth * 0.5);
    const amp = H * (0.08 + depth * 0.09) * gain;
    const freq = (0.003 + depth * 0.008) * roughness;

    ctx.beginPath();
    ctx.moveTo(0, H);
    for (let x = 0; x <= W + xStep; x += xStep) {
      const nx = x / W;
      const idx = Math.min(BIN_COUNT - 1, Math.floor(nx * (BIN_COUNT - 1)));
      const idxB = Math.min(BIN_COUNT - 1, idx + 1 + layer * 2);
      const band = smoothBins[idx] * 0.72 + peaks[idxB] * 0.28;
      const noise = Math.sin(x * freq + timeSec * (0.45 + depth * 1.2) + layer * 0.7)
        + 0.5 * Math.sin(x * freq * 2.7 + timeSec * (1 + depth * 1.8) + layer * 1.4)
        + 0.24 * Math.sin(x * freq * 5.5 - timeSec * 1.2 + layer * 2.1);
      const ridge = Math.pow(Math.max(0, band), 0.78);
      const y = baseY - ridge * amp * (0.8 + depth * 0.95) - noise * H * 0.017 * roughness * (0.5 + depth);
      if (x === 0) ctx.lineTo(0, y);
      else ctx.lineTo(x, y);
    }
    ctx.lineTo(W, H);
    ctx.closePath();

    const hue = 206 + depth * 24 + low * 12;
    const sat = 28 + depth * 12;
    const light = 23 - depth * 10 + mid * 7;
    ctx.fillStyle = `hsla(${hue},${sat}%,${light}%,0.95)`;
    ctx.fill();

    ctx.strokeStyle = `hsla(${hue + 6},${Math.min(60, sat + 10)}%,${Math.min(80, light + 18)}%,0.22)`;
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  const fog = ctx.createLinearGradient(0, H * 0.45, 0, H);
  fog.addColorStop(0, 'rgba(100,145,200,0)');
  fog.addColorStop(1, 'rgba(8,10,14,0.68)');
  ctx.fillStyle = fog;
  ctx.fillRect(0, H * 0.45, W, H * 0.55);
}

let last = performance.now();
function frame(now) {
  const dt = Math.min(48, now - last);
  last = now;
  const timeSec = now * 0.001;

  if (audioMode === 'webaudio synth') modulateSynth(timeSec);

  let hasAnalyserData = false;
  if (analyserActive) hasAnalyserData = fillAnalyserBins();
  if (!hasAnalyserData) fillPseudoBins(timeSec);

  smoothSpectrum();

  const low = averageBand(0, 14);
  const mid = averageBand(14, 44);
  const high = averageBand(44, BIN_COUNT);
  const level = (low * 0.5 + mid * 0.35 + high * 0.15) * gain;
  levelEl.textContent = `lvl ${level.toFixed(2)}`;

  drawSky(timeSec, low, mid, high);
  drawMountains(timeSec, low, mid);

  requestAnimationFrame(frame);
}

enableAudioBtn.addEventListener('click', enableAudio);

gainInput.addEventListener('input', () => {
  gain = clamp(parseFloat(gainInput.value) || 1.1, 0.35, 2.4);
  syncControls();
});

roughInput.addEventListener('input', () => {
  roughness = clamp(parseFloat(roughInput.value) || 0.95, 0.25, 2.2);
  syncControls();
});

document.addEventListener('keydown', (e) => {
  if (e.target.tagName === 'INPUT') return;
  if (e.key === 'ArrowUp') {
    e.preventDefault();
    gain = clamp(gain + 0.08, 0.35, 2.4);
    syncControls();
  } else if (e.key === 'ArrowDown') {
    e.preventDefault();
    gain = clamp(gain - 0.08, 0.35, 2.4);
    syncControls();
  } else if (e.key === 'ArrowRight') {
    e.preventDefault();
    roughness = clamp(roughness + 0.08, 0.25, 2.2);
    syncControls();
  } else if (e.key === 'ArrowLeft') {
    e.preventDefault();
    roughness = clamp(roughness - 0.08, 0.25, 2.2);
    syncControls();
  } else if (e.key === ' ') {
    e.preventDefault();
    pseudoSeed = Math.random() * 1000;
  }
});

let dragId = null;
let dragStartX = 0;
let dragStartY = 0;
let dragStartGain = gain;
let dragStartRough = roughness;
let dragMoved = false;
let dragDownAt = 0;

canvas.addEventListener('pointerdown', (e) => {
  dragId = e.pointerId;
  dragStartX = e.clientX;
  dragStartY = e.clientY;
  dragStartGain = gain;
  dragStartRough = roughness;
  dragMoved = false;
  dragDownAt = performance.now();
  if (canvas.setPointerCapture) canvas.setPointerCapture(e.pointerId);
});

canvas.addEventListener('pointermove', (e) => {
  if (dragId !== e.pointerId) return;
  const dx = e.clientX - dragStartX;
  const dy = e.clientY - dragStartY;
  if (Math.abs(dx) + Math.abs(dy) > 8) dragMoved = true;
  roughness = clamp(dragStartRough + dx / 260, 0.25, 2.2);
  gain = clamp(dragStartGain - dy / 220, 0.35, 2.4);
  syncControls();
});

function endPointer(e) {
  if (dragId !== e.pointerId) return;
  if (!dragMoved && performance.now() - dragDownAt < 240) pseudoSeed = Math.random() * 1000;
  dragId = null;
}
canvas.addEventListener('pointerup', endPointer);
canvas.addEventListener('pointercancel', endPointer);

window.addEventListener('resize', resize);
window.addEventListener('orientationchange', resize);

resize();
syncControls();
setMode('synth fallback');
requestAnimationFrame(frame);
</script>
</body>
</html>
