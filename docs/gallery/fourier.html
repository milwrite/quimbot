<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fourier Circles</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{height:100%;background:#0a0a0a;overflow:hidden;display:flex;flex-direction:column}
canvas{display:block;flex:1;width:100%}
.back{position:fixed;top:1rem;left:1rem;font:0.8rem/1 ui-monospace,SFMono-Regular,Menlo,monospace;color:#aaa;background:rgba(10,10,10,0.85);padding:0.5rem 0.8rem;border-radius:4px;text-decoration:none;border:1px solid #333;z-index:10;transition:border-color 0.2s}
.back:hover{border-color:#666;color:#fff}
.panel{background:#111;border-top:1px solid #222;padding:0.6rem 1rem;display:flex;align-items:center;justify-content:space-between;gap:0.8rem;font:0.75rem/1 ui-monospace,SFMono-Regular,Menlo,monospace;flex-shrink:0}
.panel .info{color:#ccc;white-space:nowrap}
.panel .hint{color:#555}
.panel .right{display:flex;gap:6px}
.panel button{background:rgba(255,255,255,0.06);border:1px solid #333;color:#999;font:0.75rem ui-monospace,SFMono-Regular,Menlo,monospace;padding:8px 14px;border-radius:4px;cursor:pointer;transition:all 0.2s;-webkit-tap-highlight-color:transparent}
.panel button:hover{background:rgba(255,255,255,0.12);color:#fff;border-color:#555}
.in-iframe .back,.in-iframe .panel{display:none}
</style>
</head>
<body>
<script>if(window.self!==window.top)document.body.classList.add('in-iframe');</script>
<a class="back" href="index.html">← Gallery</a>
<canvas id="c"></canvas>
<div class="panel">
<div>
<span class="info" id="info">square · 8 harmonics</span>
<span class="hint"> · tap shape · swipe ↕ harmonics</span>
</div>
<div class="right">
<button onclick="changeHarmonics(-1)">−</button>
<button onclick="changeHarmonics(1)">+</button>
<button onclick="cycleShape()">shape</button>
</div>
</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let W, H;
let time = 0;
let numHarmonics = 8;
let shapeIdx = 0;
const shapes = ['square', 'sawtooth', 'triangle', 'custom'];
const trail = [];
const maxTrail = 600;

function resize() {
  W = canvas.width = canvas.clientWidth;
  H = canvas.height = canvas.clientHeight;
  trail.length = 0;
}
window.addEventListener('resize', resize);
resize();

function updateInfo() {
  document.getElementById('info').textContent = `${shapes[shapeIdx]} · ${numHarmonics} harmonics`;
}

function changeHarmonics(d) {
  numHarmonics = Math.max(1, Math.min(30, numHarmonics + d));
  trail.length = 0;
  updateInfo();
}

function cycleShape() {
  shapeIdx = (shapeIdx + 1) % shapes.length;
  trail.length = 0;
  updateInfo();
}

function getCoeffs(shape, n) {
  switch(shape) {
    case 'square':
      if (n % 2 === 0) return null;
      return { amp: 1/n, freq: n, phase: 0 };
    case 'sawtooth':
      return { amp: (n % 2 === 0 ? -1 : 1) / n, freq: n, phase: 0 };
    case 'triangle':
      if (n % 2 === 0) return null;
      return { amp: (((n-1)/2) % 2 === 0 ? 1 : -1) / (n*n), freq: n, phase: 0 };
    case 'custom':
      return { amp: 1/(n * (1 + 0.3 * Math.sin(n*0.7))), freq: n, phase: n * 0.5 };
    default:
      return { amp: 1/n, freq: n, phase: 0 };
  }
}

function hsl(h, s, l) { return `hsl(${h},${s}%,${l}%)`; }

function draw() {
  ctx.fillStyle = 'rgba(10,10,10,0.15)';
  ctx.fillRect(0, 0, W, H);

  const cx = W * 0.3;
  const cy = H * 0.5;
  const baseR = Math.min(W, H) * 0.18;
  const shape = shapes[shapeIdx];

  let x = cx, y = cy;
  let drawn = 0;

  for (let n = 1; drawn < numHarmonics; n++) {
    const c = getCoeffs(shape, n);
    if (!c) continue;
    drawn++;

    const r = Math.abs(c.amp) * baseR;
    const angle = c.freq * time * 0.02 + c.phase;
    const hue = (drawn / numHarmonics) * 300;

    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.strokeStyle = hsl(hue, 60, 30);
    ctx.lineWidth = 0.8;
    ctx.stroke();

    const nx = x + r * Math.cos(angle);
    const ny = y + r * Math.sin(angle);
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(nx, ny);
    ctx.strokeStyle = hsl(hue, 80, 50);
    ctx.lineWidth = 1.2;
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(nx, ny, 2.5, 0, Math.PI * 2);
    ctx.fillStyle = hsl(hue, 90, 70);
    ctx.fill();

    x = nx; y = ny;
  }

  const waveStart = W * 0.5;
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(waveStart, y);
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 0.8;
  ctx.setLineDash([4, 4]);
  ctx.stroke();
  ctx.setLineDash([]);

  trail.unshift(y);
  if (trail.length > maxTrail) trail.pop();

  ctx.beginPath();
  for (let i = 0; i < trail.length; i++) {
    const wx = waveStart + i * (W * 0.48 / maxTrail);
    if (i === 0) ctx.moveTo(wx, trail[i]);
    else ctx.lineTo(wx, trail[i]);
  }
  const grad = ctx.createLinearGradient(waveStart, 0, W * 0.98, 0);
  grad.addColorStop(0, 'rgba(100,200,255,0.9)');
  grad.addColorStop(1, 'rgba(100,200,255,0.05)');
  ctx.strokeStyle = grad;
  ctx.lineWidth = 2;
  ctx.stroke();

  time++;
  requestAnimationFrame(draw);
}

// Desktop: click canvas = cycle shape
canvas.addEventListener('click', e => {
  if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;
  cycleShape();
});

// Keyboard
document.addEventListener('keydown', e => {
  if (e.target.tagName === 'INPUT') return;
  if (e.key === 'ArrowUp') { e.preventDefault(); changeHarmonics(1); }
  else if (e.key === 'ArrowDown') { e.preventDefault(); changeHarmonics(-1); }
  else if (e.key === ' ') { e.preventDefault(); cycleShape(); }
});

// Touch gestures
let touchX = 0, touchY = 0, touchTime = 0;
canvas.addEventListener('touchstart', e => {
  touchX = e.touches[0].clientX;
  touchY = e.touches[0].clientY;
  touchTime = Date.now();
}, { passive: true });
canvas.addEventListener('touchend', e => {
  const dx = e.changedTouches[0].clientX - touchX;
  const dy = e.changedTouches[0].clientY - touchY;
  const dt = Date.now() - touchTime;
  const dist = Math.sqrt(dx*dx + dy*dy);

  if (dist < 20 && dt < 300) {
    cycleShape();
  } else if (dist > 40 && dt < 500 && Math.abs(dy) > Math.abs(dx)) {
    changeHarmonics(dy < 0 ? 1 : -1);
  }
  e.preventDefault();
}, { passive: false });

draw();
</script>
</body>
</html>
