<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Rubik Patterns</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{height:100%;background:#0a0a0a;overflow:hidden;display:flex;flex-direction:column}
canvas{display:block;flex:1;width:100%;cursor:pointer}
.back{position:fixed;top:1rem;left:1rem;font:0.8rem/1 ui-monospace,SFMono-Regular,Menlo,monospace;color:#aaa;background:rgba(10,10,10,0.85);padding:0.5rem 0.8rem;border-radius:4px;text-decoration:none;border:1px solid #333;z-index:10;transition:border-color 0.2s}
.back:hover{border-color:#666;color:#fff}
.panel{background:#111;border-top:1px solid #222;padding:0.6rem 1rem;display:flex;align-items:center;justify-content:space-between;gap:0.8rem;font:0.75rem/1 ui-monospace,SFMono-Regular,Menlo,monospace;flex-shrink:0}
.panel .info{color:#ccc;white-space:nowrap}
.panel .hint{color:#555}
.panel .right{display:flex;gap:6px}
.panel button{background:rgba(255,255,255,0.06);border:1px solid #333;color:#999;font:0.75rem ui-monospace,SFMono-Regular,Menlo,monospace;padding:5px 10px;border-radius:4px;cursor:pointer;transition:all 0.2s}
.panel button:hover{background:rgba(255,255,255,0.12);color:#fff;border-color:#555}
.in-iframe .back,.in-iframe .panel{display:none}
</style>
</head>
<body>
<script>if(window.self!==window.top)document.body.classList.add('in-iframe');</script>
<a class="back" href="index.html">← Gallery</a>
<canvas id="c"></canvas>
<div class="panel">
<div>
<span class="info" id="info">3×3 · solved</span>
<span class="hint"> · tap/click scramble · swipe ↔ size · swipe ↑ solve · swipe ↓ reset</span>
</div>
<div class="right">
<button onclick="doScramble()">scramble</button>
<button onclick="doSolve()">solve</button>
<button onclick="doReset()">reset</button>
<button onclick="cycleSize()">size</button>
</div>
</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

// Standard Rubik's colors: U=white, D=yellow, F=green, B=blue, R=red, L=orange
const COLORS = ['#ffffff','#ffd500','#009e60','#0051ba','#c41e3a','#ff5800'];
// Face indices: U=0, D=1, F=2, B=3, R=4, L=5

let n = 3; // grid size
const sizes = [2, 3, 4, 5, 7];
let sizeIdx = 1;
let cube = [];
let scrambled = false;
let moveHistory = []; // for solve playback
let solving = false;
let solveQueue = [];
let solveTimer = 0;

// ── Cube Data ──

function initCube() {
  cube = [];
  for (let f = 0; f < 6; f++)
    cube[f] = Array.from({length: n}, () => Array(n).fill(COLORS[f]));
  scrambled = false;
  moveHistory = [];
  solveQueue = [];
  solving = false;
  updateInfo();
}

function cloneCube() {
  return cube.map(f => f.map(r => [...r]));
}

// ── Face Rotation ──

function rotateCW(f) {
  const old = cube[f].map(r => [...r]);
  for (let r = 0; r < n; r++)
    for (let c = 0; c < n; c++)
      cube[f][c][n - 1 - r] = old[r][c];
}

// ── Strip Helpers ──

function getRow(f, r) { return cube[f][r].slice(); }
function setRow(f, r, v) { for (let i = 0; i < n; i++) cube[f][r][i] = v[i]; }
function getCol(f, c) { return cube[f].map(row => row[c]); }
function setCol(f, c, v) { for (let i = 0; i < n; i++) cube[f][i][c] = v[i]; }
function rev(a) { return a.slice().reverse(); }

// ── The 6 Moves ──
// Each move: rotate face CW, then cycle 4 adjacent strips.
// Derived by tracing physical corner/edge sticker movements.
//
// Convention:
//   All faces viewed head-on. B from behind (B[0][0] = cube's top-right-back).
//   R from right (R[0][0] = top-front). L from left (L[0][0] = top-back).
//   U from above (U[0][0] = back-left). D from below (D[0][0] = front-left).

function moveU() {
  // U CW: top rows cycle F←L←B←R←F (all direct, no reversals)
  rotateCW(0);
  const t = getRow(2, 0);
  setRow(2, 0, getRow(5, 0));   // F ← L
  setRow(5, 0, getRow(3, 0));   // L ← B
  setRow(3, 0, getRow(4, 0));   // B ← R
  setRow(4, 0, t);              // R ← F
}

function moveD() {
  // D CW (from below): bottom rows cycle F←L←B←R←F (all direct)
  rotateCW(1);
  const t = getRow(2, n-1);
  setRow(2, n-1, getRow(5, n-1));   // F ← L
  setRow(5, n-1, getRow(3, n-1));   // L ← B
  setRow(3, n-1, getRow(4, n-1));   // B ← R
  setRow(4, n-1, t);                // R ← F
}

function moveF() {
  // F CW: U[n-1]←L_col[n-1], L_col[n-1]←rev(D[0]), D[0]←rev(R_col[0]), R_col[0]←U[n-1]
  rotateCW(2);
  const t = getRow(0, n-1);
  setRow(0, n-1, getCol(5, n-1));          // U ← L col (direct)
  setCol(5, n-1, rev(getRow(1, 0)));       // L ← rev(D row)
  setRow(1, 0, rev(getCol(4, 0)));         // D ← rev(R col)
  setCol(4, 0, t);                         // R ← U (direct)
}

function moveB() {
  // B CW (from behind): U[0]←R_col[n-1], R_col[n-1]←rev(D[n-1]), D[n-1]←L_col[0], L_col[0]←rev(U[0])
  rotateCW(3);
  const t = getRow(0, 0);
  setRow(0, 0, getCol(4, n-1));            // U ← R col (direct)
  setCol(4, n-1, rev(getRow(1, n-1)));     // R ← rev(D row)
  setRow(1, n-1, getCol(5, 0));            // D ← L col (direct)
  setCol(5, 0, rev(t));                    // L ← rev(U)
}

function moveR() {
  // R CW: U_col[n-1]←F_col[n-1], F_col[n-1]←D_col[n-1], D_col[n-1]←rev(B_col[0]), B_col[0]←rev(U_col[n-1])
  rotateCW(4);
  const t = getCol(0, n-1);
  setCol(0, n-1, getCol(2, n-1));          // U ← F (direct)
  setCol(2, n-1, getCol(1, n-1));          // F ← D (direct)
  setCol(1, n-1, rev(getCol(3, 0)));       // D ← rev(B col 0)
  setCol(3, 0, rev(t));                    // B ← rev(U)
}

function moveL() {
  // L CW: U_col[0]←rev(B_col[n-1]), B_col[n-1]←rev(D_col[0]), D_col[0]←F_col[0], F_col[0]←U_col[0]
  rotateCW(5);
  const t = getCol(0, 0);
  setCol(0, 0, rev(getCol(3, n-1)));       // U ← rev(B col n-1)
  setCol(3, n-1, rev(getCol(1, 0)));       // B ← rev(D col 0)
  setCol(1, 0, getCol(2, 0));              // D ← F (direct)
  setCol(2, 0, t);                         // F ← U (direct)
}

// Inverse moves (3x CW = 1x CCW)
function moveUi() { moveU(); moveU(); moveU(); }
function moveDi() { moveD(); moveD(); moveD(); }
function moveFi() { moveF(); moveF(); moveF(); }
function moveBi() { moveB(); moveB(); moveB(); }
function moveRi() { moveR(); moveR(); moveR(); }
function moveLi() { moveL(); moveL(); moveL(); }

const MOVES = [moveU, moveD, moveF, moveB, moveR, moveL];
const INVERSE = [moveUi, moveDi, moveFi, moveBi, moveRi, moveLi];
const MOVE_NAMES = ['U','D','F','B','R','L'];

// ── Self-Test: each move applied 4 times must return to identity ──

function selfTest() {
  const saved = cloneCube();
  let ok = true;
  for (let m = 0; m < 6; m++) {
    initCube();
    for (let i = 0; i < 4; i++) MOVES[m]();
    for (let f = 0; f < 6; f++)
      for (let r = 0; r < n; r++)
        for (let c = 0; c < n; c++)
          if (cube[f][r][c] !== COLORS[f]) { ok = false; break; }
    if (!ok) { console.error('Move ' + MOVE_NAMES[m] + ' failed 4x identity test!'); break; }
  }
  // Restore
  cube = saved;
  if (ok) console.log('All moves passed 4x identity test ✓');
  return ok;
}

// ── Scramble & Solve ──

function doScramble() {
  solving = false;
  solveQueue = [];
  moveHistory = [];
  const count = n * 20;
  for (let i = 0; i < count; i++) {
    const m = Math.floor(Math.random() * 6);
    const turns = 1 + Math.floor(Math.random() * 3);
    for (let t = 0; t < turns; t++) {
      MOVES[m]();
      moveHistory.push(m);
    }
  }
  scrambled = true;
  updateInfo();
}

function doSolve() {
  if (!scrambled || moveHistory.length === 0) return;
  solving = true;
  // Build reverse queue
  solveQueue = moveHistory.slice().reverse().map(m => INVERSE[m]);
  moveHistory = [];
  solveTimer = 0;
  updateInfo();
}

function doReset() {
  initCube();
}

function cycleSize() {
  sizeIdx = (sizeIdx + 1) % sizes.length;
  n = sizes[sizeIdx];
  initCube();
}

function updateInfo() {
  const state = solving ? 'solving...' : (scrambled ? 'scrambled' : 'solved');
  document.getElementById('info').textContent = `${n}×${n} · ${state}`;
}

// ── Drawing ──
// Isometric: x=right-down, y=left-down, z=up.
// Cube occupies [0,n]³. Visible faces: top(z=n), left(y=n), right(x=n).
// These three faces share edges at the center vertex (n,n,n).

const COS30 = Math.cos(Math.PI / 6);
const SIN30 = 0.5;

function iso(x, y, z, s, ox, oy) {
  return [
    ox + (x - y) * COS30 * s,
    oy + (x + y) * SIN30 * s - z * s
  ];
}

function quad(p1, p2, p3, p4, fill) {
  ctx.beginPath();
  ctx.moveTo(p1[0], p1[1]);
  ctx.lineTo(p2[0], p2[1]);
  ctx.lineTo(p3[0], p3[1]);
  ctx.lineTo(p4[0], p4[1]);
  ctx.closePath();
  ctx.fillStyle = fill;
  ctx.fill();
  ctx.strokeStyle = '#0a0a0a';
  ctx.lineWidth = Math.max(1, Math.min(2.5, 120 / (n * 20)));
  ctx.stroke();
}

function darken(hex, factor) {
  const r = parseInt(hex.slice(1,3), 16);
  const g = parseInt(hex.slice(3,5), 16);
  const b = parseInt(hex.slice(5,7), 16);
  return `rgb(${Math.floor(r*factor)},${Math.floor(g*factor)},${Math.floor(b*factor)})`;
}

function draw() {
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, W, H);

  const s = Math.min(W, H) * 0.45 / n;
  const ox = W / 2;
  const oy = H / 2;
  const g = 0.06; // gap fraction of cell

  // Top face = U (cube[0]) at z=n
  // U[0][0] = back-left → iso position (x=0, y=n, z=n) = top-left of diamond
  // U[r][c]: r increases front (y decreases), c increases right (x increases)
  for (let r = 0; r < n; r++) {
    for (let c = 0; c < n; c++) {
      const x0 = c + g, x1 = c + 1 - g;
      const y0 = (n - 1 - r) + g, y1 = (n - r) - g;
      quad(
        iso(x0, y0, n, s, ox, oy),
        iso(x1, y0, n, s, ox, oy),
        iso(x1, y1, n, s, ox, oy),
        iso(x0, y1, n, s, ox, oy),
        cube[0][r][c]
      );
    }
  }

  // Left face = F (cube[2]) at y=n
  // F[0][0] = top-left of front face = top of left parallelogram
  // F[r][c]: r increases downward (z decreases), c increases right (x increases)
  for (let r = 0; r < n; r++) {
    for (let c = 0; c < n; c++) {
      const x0 = c + g, x1 = c + 1 - g;
      const z0 = (n - 1 - r) + g, z1 = (n - r) - g;
      quad(
        iso(x0, n, z1, s, ox, oy),
        iso(x1, n, z1, s, ox, oy),
        iso(x1, n, z0, s, ox, oy),
        iso(x0, n, z0, s, ox, oy),
        darken(cube[2][r][c], 0.7)
      );
    }
  }

  // Right face = R (cube[4]) at x=n
  // R[0][0] = top-front of right face = top of right parallelogram
  // R[r][c]: r increases downward (z decreases), c increases back (y increases)
  for (let r = 0; r < n; r++) {
    for (let c = 0; c < n; c++) {
      const y0 = c + g, y1 = c + 1 - g;
      const z0 = (n - 1 - r) + g, z1 = (n - r) - g;
      quad(
        iso(n, y0, z1, s, ox, oy),
        iso(n, y1, z1, s, ox, oy),
        iso(n, y1, z0, s, ox, oy),
        iso(n, y0, z0, s, ox, oy),
        darken(cube[4][r][c], 0.5)
      );
    }
  }
}

// ── Animation Loop ──

let autoTimer = 0;

function animate() {
  // Solve animation: apply one inverse move per interval
  if (solving && solveQueue.length > 0) {
    solveTimer++;
    const speed = Math.max(1, Math.min(4, Math.floor(solveQueue.length / 20)));
    if (solveTimer % 3 === 0) {
      for (let i = 0; i < speed && solveQueue.length > 0; i++) {
        solveQueue.shift()();
      }
      if (solveQueue.length === 0) {
        solving = false;
        scrambled = false;
        updateInfo();
      }
    }
  }

  // Auto-scramble: apply random moves when idle and scrambled
  if (!solving && scrambled) {
    autoTimer++;
    if (autoTimer % 60 === 0) {
      const m = Math.floor(Math.random() * 6);
      MOVES[m]();
      moveHistory.push(m);
    }
  }

  draw();
  requestAnimationFrame(animate);
}

// ── Events ──

// Click for desktop (touch handled separately above)
canvas.addEventListener('click', e => {
  if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;
  doScramble();
});

document.addEventListener('keydown', e => {
  // Only handle if not typing in an input
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
  if (e.key === 's' || e.key === 'S') { e.preventDefault(); cycleSize(); }
  else if (e.key === 'r' || e.key === 'R') { e.preventDefault(); doReset(); }
  else if (e.key === 'v' || e.key === 'V') { e.preventDefault(); doSolve(); }
  else if (e.key === ' ') { e.preventDefault(); doScramble(); }
});

// ── Touch Gestures ──
let touchStartX = 0, touchStartY = 0, touchStartTime = 0;
canvas.addEventListener('touchstart', e => {
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
  touchStartTime = Date.now();
}, {passive: true});
canvas.addEventListener('touchend', e => {
  const dx = e.changedTouches[0].clientX - touchStartX;
  const dy = e.changedTouches[0].clientY - touchStartY;
  const dt = Date.now() - touchStartTime;
  const dist = Math.sqrt(dx*dx + dy*dy);

  if (dist < 20 && dt < 300) {
    // Tap = scramble
    doScramble();
  } else if (dist > 50 && dt < 500) {
    if (Math.abs(dx) > Math.abs(dy)) {
      // Horizontal swipe = cycle size
      cycleSize();
    } else if (dy < 0) {
      // Swipe up = solve
      doSolve();
    } else {
      // Swipe down = reset
      doReset();
    }
  }
  e.preventDefault();
}, {passive: false});

// ── Resize ──

function resize() {
  W = canvas.width = canvas.clientWidth;
  H = canvas.height = canvas.clientHeight;
}
window.addEventListener('resize', resize);

// ── Init ──

resize();
initCube();
selfTest();
doScramble();
animate();
</script>
</body>
</html>
