<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Rubik Patterns</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  body{background:#0a0a0a;overflow:hidden;cursor:pointer}
  canvas{display:block}
  .back{position:fixed;top:1rem;left:1rem;font:0.8rem/1 ui-monospace,SFMono-Regular,Menlo,monospace;color:#aaa;background:rgba(10,10,10,0.85);padding:0.5rem 0.8rem;border-radius:4px;text-decoration:none;border:1px solid #333;z-index:10;transition:border-color 0.2s}
  .back:hover{border-color:#666;color:#fff}
  .label{position:fixed;bottom:1rem;left:1rem;font:0.75rem/1.4 ui-monospace,SFMono-Regular,Menlo,monospace;color:#888;background:rgba(10,10,10,0.85);padding:0.4rem 0.7rem;border-radius:4px;pointer-events:none}
  .ctrl{position:fixed;top:1rem;right:1rem;font:0.75rem/1 ui-monospace,SFMono-Regular,Menlo,monospace;color:#aaa;background:rgba(10,10,10,0.85);padding:0.5rem 0.8rem;border-radius:4px;border:1px solid #333;cursor:pointer;z-index:10;transition:border-color 0.2s}
  .ctrl:hover{border-color:#666;color:#fff}
  .in-iframe .back,.in-iframe .label,.in-iframe .ctrl{display:none}
</style>
</head>
<body>
<script>if(window.self!==window.top)document.body.classList.add('in-iframe');</script>
<a class="back" href="index.html">← Gallery</a>
<button class="ctrl" id="sizeBtn">size: 3×3</button>
<canvas id="c"></canvas>
<div class="label">click to scramble · S to change size</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const sizeBtn = document.getElementById('sizeBtn');

let W, H;
let gridSize = 3;
const sizes = [2, 3, 4, 5, 7];
let sizeIdx = 1;

const faceColors = ['#c41e3a','#ff5800','#ffd500','#009e60','#0051ba','#ffffff'];

// faces[0] = top, faces[1] = left, faces[2] = right
let faces = [];

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function initFaces() {
  faces = [];
  for (let f = 0; f < 3; f++) {
    const face = [];
    for (let r = 0; r < gridSize; r++) {
      const row = [];
      for (let c = 0; c < gridSize; c++) {
        row.push(faceColors[f * 2 + ((r + c) % 2)]);
      }
      face.push(row);
    }
    faces.push(face);
  }
}

function scramble() {
  for (let i = 0; i < gridSize * 12; i++) {
    const f = Math.floor(Math.random() * 3);
    const idx = Math.floor(Math.random() * gridSize);
    const dir = Math.random() > 0.5 ? 1 : -1;
    if (Math.random() > 0.5) {
      rotateRow(f, idx, dir);
    } else {
      rotateCol(f, idx, dir);
    }
  }
}

function rotateRow(f, row, dir) {
  const face = faces[f];
  if (dir > 0) {
    const tmp = face[row][gridSize - 1];
    for (let c = gridSize - 1; c > 0; c--) face[row][c] = face[row][c-1];
    face[row][0] = tmp;
  } else {
    const tmp = face[row][0];
    for (let c = 0; c < gridSize - 1; c++) face[row][c] = face[row][c+1];
    face[row][gridSize - 1] = tmp;
  }
}

function rotateCol(f, col, dir) {
  const face = faces[f];
  if (dir > 0) {
    const tmp = face[gridSize - 1][col];
    for (let r = gridSize - 1; r > 0; r--) face[r][col] = face[r-1][col];
    face[0][col] = tmp;
  } else {
    const tmp = face[0][col];
    for (let r = 0; r < gridSize - 1; r++) face[r][col] = face[r+1][col];
    face[gridSize - 1][col] = tmp;
  }
}

function darken(hex, factor) {
  const r = parseInt(hex.slice(1,3), 16);
  const g = parseInt(hex.slice(3,5), 16);
  const b = parseInt(hex.slice(5,7), 16);
  return `rgb(${Math.floor(r*factor)},${Math.floor(g*factor)},${Math.floor(b*factor)})`;
}

// Isometric projection helpers
// Unit vectors for isometric: right = (cos30, sin30), left = (-cos30, sin30), down = (0, 1)
const COS30 = Math.cos(Math.PI / 6);
const SIN30 = 0.5;

function isoProject(x, y, z, cellSize, cx, cy) {
  // x = right axis, y = depth (left-back), z = up
  const px = cx + (x - y) * COS30 * cellSize;
  const py = cy + (x + y) * SIN30 * cellSize - z * cellSize;
  return [px, py];
}

function drawQuad(p1, p2, p3, p4, color) {
  ctx.beginPath();
  ctx.moveTo(p1[0], p1[1]);
  ctx.lineTo(p2[0], p2[1]);
  ctx.lineTo(p3[0], p3[1]);
  ctx.lineTo(p4[0], p4[1]);
  ctx.closePath();
  ctx.fillStyle = color;
  ctx.fill();
  ctx.strokeStyle = '#1a1a1a';
  ctx.lineWidth = 1.5;
  ctx.stroke();
}

function drawCube() {
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, W, H);

  const cellSize = Math.min(W, H) * 0.55 / gridSize;
  const cx = W / 2;
  const cy = H / 2 + gridSize * cellSize * 0.15;
  const n = gridSize;
  const g = 0.08; // gap as fraction of cell

  // Top face (faces[0]) — z = n, x and y vary
  for (let r = 0; r < n; r++) {
    for (let c = 0; c < n; c++) {
      const x0 = c + g, x1 = c + 1 - g;
      const y0 = r + g, y1 = r + 1 - g;
      const p1 = isoProject(x0, y0, n, cellSize, cx, cy);
      const p2 = isoProject(x1, y0, n, cellSize, cx, cy);
      const p3 = isoProject(x1, y1, n, cellSize, cx, cy);
      const p4 = isoProject(x0, y1, n, cellSize, cx, cy);
      drawQuad(p1, p2, p3, p4, faces[0][r][c]);
    }
  }

  // Left face (faces[1]) — x = 0, y and z vary
  for (let r = 0; r < n; r++) {
    for (let c = 0; c < n; c++) {
      const y0 = c + g, y1 = c + 1 - g;
      const z0 = (n - 1 - r) + g, z1 = (n - r) - g;
      const p1 = isoProject(0, y0, z1, cellSize, cx, cy);
      const p2 = isoProject(0, y1, z1, cellSize, cx, cy);
      const p3 = isoProject(0, y1, z0, cellSize, cx, cy);
      const p4 = isoProject(0, y0, z0, cellSize, cx, cy);
      drawQuad(p1, p2, p3, p4, darken(faces[1][r][c], 0.65));
    }
  }

  // Right face (faces[2]) — y = 0, x and z vary
  for (let r = 0; r < n; r++) {
    for (let c = 0; c < n; c++) {
      const x0 = c + g, x1 = c + 1 - g;
      const z0 = (n - 1 - r) + g, z1 = (n - r) - g;
      const p1 = isoProject(x0, 0, z1, cellSize, cx, cy);
      const p2 = isoProject(x1, 0, z1, cellSize, cx, cy);
      const p3 = isoProject(x1, 0, z0, cellSize, cx, cy);
      const p4 = isoProject(x0, 0, z0, cellSize, cx, cy);
      drawQuad(p1, p2, p3, p4, darken(faces[2][r][c], 0.45));
    }
  }
}

let autoTimer = 0;
function animate() {
  autoTimer++;
  if (autoTimer % 45 === 0) {
    const f = Math.floor(Math.random() * 3);
    const idx = Math.floor(Math.random() * gridSize);
    if (Math.random() > 0.5) {
      rotateRow(f, idx, Math.random() > 0.5 ? 1 : -1);
    } else {
      rotateCol(f, idx, Math.random() > 0.5 ? 1 : -1);
    }
  }
  drawCube();
  requestAnimationFrame(animate);
}

canvas.addEventListener('click', () => scramble());

function cycleSize() {
  sizeIdx = (sizeIdx + 1) % sizes.length;
  gridSize = sizes[sizeIdx];
  sizeBtn.textContent = `size: ${gridSize}×${gridSize}`;
  initFaces();
  scramble();
}

document.addEventListener('keydown', e => {
  if (e.key === 's' || e.key === 'S') cycleSize();
});

sizeBtn.addEventListener('click', e => {
  e.stopPropagation();
  cycleSize();
});

initFaces();
scramble();
animate();
</script>
</body>
</html>
