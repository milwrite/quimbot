<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Rubik Patterns</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{height:100%;background:#0a0a0a;overflow:hidden;display:flex;flex-direction:column}
canvas{display:block;flex:1;width:100%;cursor:pointer}
.back{position:fixed;top:1rem;left:1rem;font:0.8rem/1 ui-monospace,SFMono-Regular,Menlo,monospace;color:#aaa;background:rgba(10,10,10,0.85);padding:0.5rem 0.8rem;border-radius:4px;text-decoration:none;border:1px solid #333;z-index:10;transition:border-color 0.2s}
.back:hover{border-color:#666;color:#fff}
.panel{background:#111;border-top:1px solid #222;padding:0.6rem 1rem;display:flex;align-items:center;justify-content:space-between;gap:0.8rem;font:0.75rem/1 ui-monospace,SFMono-Regular,Menlo,monospace;flex-shrink:0}
.panel .info{color:#ccc;white-space:nowrap}
.panel .hint{color:#555}
.panel .right{display:flex;gap:6px}
.panel button{background:rgba(255,255,255,0.06);border:1px solid #333;color:#999;font:0.75rem ui-monospace,SFMono-Regular,Menlo,monospace;padding:5px 10px;border-radius:4px;cursor:pointer;transition:all 0.2s}
.panel button:hover{background:rgba(255,255,255,0.12);color:#fff;border-color:#555}
.in-iframe .back,.in-iframe .panel{display:none}
</style>
</head>
<body>
<script>if(window.self!==window.top)document.body.classList.add('in-iframe');</script>
<a class="back" href="index.html">← Gallery</a>
<canvas id="c"></canvas>
<div class="panel">
<div>
<span class="info" id="info">3×3 · solved</span>
<span class="hint"> · tap/click scramble · swipe ↔ size · swipe ↑ solve · swipe ↓ reset</span>
</div>
<div class="right">
<button onclick="doScramble()">scramble</button>
<button onclick="doSolve()">solve</button>
<button onclick="doReset()">reset</button>
<button onclick="cycleSize()">size</button>
</div>
</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

// Standard Rubik's colors: U=white, D=yellow, F=green, B=blue, R=red, L=orange
const COLORS = ['#ffffff','#ffd500','#009e60','#0051ba','#c41e3a','#ff5800'];
// Face indices: U=0, D=1, F=2, B=3, R=4, L=5

let n = 3; // grid size
const sizes = [2, 3, 4, 5, 7];
let sizeIdx = 1;
let cube = [];
let scrambled = false;
let moveHistory = []; // for solve playback
let solving = false;
let solveQueue = [];
let solveTimer = 0;

// ── Cube Data ──

function initCube() {
  cube = [];
  for (let f = 0; f < 6; f++)
    cube[f] = Array.from({length: n}, () => Array(n).fill(COLORS[f]));
  scrambled = false;
  moveHistory = [];
  solveQueue = [];
  solving = false;
  updateInfo();
}

function cloneCube() {
  return cube.map(f => f.map(r => [...r]));
}

// ── Face Rotation ──

function rotateCW(f) {
  const old = cube[f].map(r => [...r]);
  for (let r = 0; r < n; r++)
    for (let c = 0; c < n; c++)
      cube[f][c][n - 1 - r] = old[r][c];
}

// ── Strip Helpers ──

function getRow(f, r) { return cube[f][r].slice(); }
function setRow(f, r, v) { for (let i = 0; i < n; i++) cube[f][r][i] = v[i]; }
function getCol(f, c) { return cube[f].map(row => row[c]); }
function setCol(f, c, v) { for (let i = 0; i < n; i++) cube[f][i][c] = v[i]; }
function rev(a) { return a.slice().reverse(); }

// ── The 6 Moves ──
// Each move: rotate face CW, then cycle 4 adjacent strips.
// Derived by tracing physical corner/edge sticker movements.
//
// Convention:
//   All faces viewed head-on. B from behind (B[0][0] = cube's top-right-back).
//   R from right (R[0][0] = top-front). L from left (L[0][0] = top-back).
//   U from above (U[0][0] = back-left). D from below (D[0][0] = front-left).

// ── Layer Moves ──
// Each move takes an optional depth d (0 = outermost, default).
// Only d=0 rotates the face itself; inner layers just cycle strips.

function moveU(d) {
  d = d || 0;
  if (d === 0) rotateCW(0);
  const t = getRow(2, d);
  setRow(2, d, getRow(5, d));
  setRow(5, d, getRow(3, d));
  setRow(3, d, getRow(4, d));
  setRow(4, d, t);
}

function moveD(d) {
  d = d || 0;
  if (d === 0) rotateCW(1);
  const row = n - 1 - d;
  const t = getRow(2, row);
  setRow(2, row, getRow(5, row));
  setRow(5, row, getRow(3, row));
  setRow(3, row, getRow(4, row));
  setRow(4, row, t);
}

function moveF(d) {
  d = d || 0;
  if (d === 0) rotateCW(2);
  const uRow = n - 1 - d;
  const dRow = d;
  const rCol = d;
  const lCol = n - 1 - d;
  const t = getRow(0, uRow);
  setRow(0, uRow, getCol(5, lCol));
  setCol(5, lCol, rev(getRow(1, dRow)));
  setRow(1, dRow, rev(getCol(4, rCol)));
  setCol(4, rCol, t);
}

function moveB(d) {
  d = d || 0;
  if (d === 0) rotateCW(3);
  const uRow = d;
  const dRow = n - 1 - d;
  const rCol = n - 1 - d;
  const lCol = d;
  const t = getRow(0, uRow);
  setRow(0, uRow, getCol(4, rCol));
  setCol(4, rCol, rev(getRow(1, dRow)));
  setRow(1, dRow, getCol(5, lCol));
  setCol(5, lCol, rev(t));
}

function moveR(d) {
  d = d || 0;
  if (d === 0) rotateCW(4);
  const col = n - 1 - d;
  const bCol = d;
  const t = getCol(0, col);
  setCol(0, col, getCol(2, col));
  setCol(2, col, getCol(1, col));
  setCol(1, col, rev(getCol(3, bCol)));
  setCol(3, bCol, rev(t));
}

function moveL(d) {
  d = d || 0;
  if (d === 0) rotateCW(5);
  const col = d;
  const bCol = n - 1 - d;
  const t = getCol(0, col);
  setCol(0, col, rev(getCol(3, bCol)));
  setCol(3, bCol, rev(getCol(1, col)));
  setCol(1, col, getCol(2, col));
  setCol(2, col, t);
}

// Inverse moves (3x CW = 1x CCW)
function moveUi(d) { moveU(d); moveU(d); moveU(d); }
function moveDi(d) { moveD(d); moveD(d); moveD(d); }
function moveFi(d) { moveF(d); moveF(d); moveF(d); }
function moveBi(d) { moveB(d); moveB(d); moveB(d); }
function moveRi(d) { moveR(d); moveR(d); moveR(d); }
function moveLi(d) { moveL(d); moveL(d); moveL(d); }

const MOVES = [moveU, moveD, moveF, moveB, moveR, moveL];
const INVERSE = [moveUi, moveDi, moveFi, moveBi, moveRi, moveLi];
const MOVE_NAMES = ['U','D','F','B','R','L'];

// ── Self-Test: each move applied 4 times must return to identity ──

function selfTest() {
  const saved = cloneCube();
  let ok = true;
  const maxD = Math.floor(n / 2);
  for (let m = 0; m < 6; m++) {
    for (let d = 0; d < maxD; d++) {
      initCube();
      for (let i = 0; i < 4; i++) MOVES[m](d);
      for (let f = 0; f < 6; f++)
        for (let r = 0; r < n; r++)
          for (let c = 0; c < n; c++)
            if (cube[f][r][c] !== COLORS[f]) { ok = false; break; }
      if (!ok) { console.error('Move ' + MOVE_NAMES[m] + ' depth ' + d + ' failed 4x identity test!'); break; }
    }
    if (!ok) break;
  }
  cube = saved;
  if (ok) console.log('All moves (all layers) passed 4x identity test ✓');
  return ok;
}

// ── Scramble & Solve ──

function doScramble() {
  solving = false;
  solveQueue = [];
  moveHistory = [];
  const maxDepth = Math.floor(n / 2); // inner layers to scramble
  const count = n * 25;
  for (let i = 0; i < count; i++) {
    const m = Math.floor(Math.random() * 6);
    const d = Math.floor(Math.random() * maxDepth);
    const turns = 1 + Math.floor(Math.random() * 3);
    for (let t = 0; t < turns; t++) {
      MOVES[m](d);
      moveHistory.push({m, d});
    }
  }
  scrambled = true;
  updateInfo();
}

function doSolve() {
  if (!scrambled) return;
  if (moveHistory.length === 0) { doReset(); return; }
  solving = true;
  solveQueue = moveHistory.slice().reverse();
  moveHistory = [];
  solveTimer = 0;
  updateInfo();
}

function doReset() {
  initCube();
}

function cycleSize() {
  sizeIdx = (sizeIdx + 1) % sizes.length;
  n = sizes[sizeIdx];
  initCube();
}

function updateInfo() {
  const state = solving ? 'solving...' : (scrambled ? 'scrambled' : 'solved');
  document.getElementById('info').textContent = `${n}×${n} · ${state}`;
}

// ── Drawing ──
// Isometric: x=right-down, y=left-down, z=up.
// Cube occupies [0,n]³. Visible faces: top(z=n), left(y=n), right(x=n).
// These three faces share edges at the center vertex (n,n,n).

const COS30 = Math.cos(Math.PI / 6);
const SIN30 = 0.5;

function iso(x, y, z, s, ox, oy) {
  return [
    ox + (x - y) * COS30 * s,
    oy + (x + y) * SIN30 * s - z * s
  ];
}

function quad(p1, p2, p3, p4, fill) {
  ctx.beginPath();
  ctx.moveTo(p1[0], p1[1]);
  ctx.lineTo(p2[0], p2[1]);
  ctx.lineTo(p3[0], p3[1]);
  ctx.lineTo(p4[0], p4[1]);
  ctx.closePath();
  ctx.fillStyle = fill;
  ctx.fill();
  ctx.strokeStyle = '#0a0a0a';
  ctx.lineWidth = Math.max(1, Math.min(2.5, 120 / (n * 20)));
  ctx.stroke();
}

function darken(hex, factor) {
  const r = parseInt(hex.slice(1,3), 16);
  const g = parseInt(hex.slice(3,5), 16);
  const b = parseInt(hex.slice(5,7), 16);
  return `rgb(${Math.floor(r*factor)},${Math.floor(g*factor)},${Math.floor(b*factor)})`;
}

function draw() {
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, W, H);

  const s = Math.min(W, H) * 0.45 / n;
  const ox = W / 2;
  const oy = H / 2;
  const g = 0.06; // gap fraction of cell

  // Top face = U (cube[0]) at z=n
  // U[0][0] = back-left → iso position (x=0, y=n, z=n) = top-left of diamond
  // U[r][c]: r increases front (y decreases), c increases right (x increases)
  for (let r = 0; r < n; r++) {
    for (let c = 0; c < n; c++) {
      const x0 = c + g, x1 = c + 1 - g;
      const y0 = (n - 1 - r) + g, y1 = (n - r) - g;
      quad(
        iso(x0, y0, n, s, ox, oy),
        iso(x1, y0, n, s, ox, oy),
        iso(x1, y1, n, s, ox, oy),
        iso(x0, y1, n, s, ox, oy),
        cube[0][r][c]
      );
    }
  }

  // Left face = F (cube[2]) at y=n
  // F[0][0] = top-left of front face = top of left parallelogram
  // F[r][c]: r increases downward (z decreases), c increases right (x increases)
  for (let r = 0; r < n; r++) {
    for (let c = 0; c < n; c++) {
      const x0 = c + g, x1 = c + 1 - g;
      const z0 = (n - 1 - r) + g, z1 = (n - r) - g;
      quad(
        iso(x0, n, z1, s, ox, oy),
        iso(x1, n, z1, s, ox, oy),
        iso(x1, n, z0, s, ox, oy),
        iso(x0, n, z0, s, ox, oy),
        darken(cube[2][r][c], 0.7)
      );
    }
  }

  // Right face = R (cube[4]) at x=n
  // R[0][0] = top-front of right face = top of right parallelogram
  // R[r][c]: r increases downward (z decreases), c increases back (y increases)
  for (let r = 0; r < n; r++) {
    for (let c = 0; c < n; c++) {
      const y0 = c + g, y1 = c + 1 - g;
      const z0 = (n - 1 - r) + g, z1 = (n - r) - g;
      quad(
        iso(n, y0, z1, s, ox, oy),
        iso(n, y1, z1, s, ox, oy),
        iso(n, y1, z0, s, ox, oy),
        iso(n, y0, z0, s, ox, oy),
        darken(cube[4][r][c], 0.5)
      );
    }
  }
}

// ── Animation Loop ──

let autoTimer = 0;

function animate() {
  // Solve animation: apply inverse moves at a visible pace
  if (solving && solveQueue.length > 0) {
    solveTimer++;
    if (solveTimer % 2 === 0) {
      // Apply 1-3 inverse moves per tick depending on queue size
      const batch = solveQueue.length > 100 ? 3 : solveQueue.length > 30 ? 2 : 1;
      for (let i = 0; i < batch && solveQueue.length > 0; i++) {
        const move = solveQueue.shift();
        INVERSE[move.m](move.d);
      }
    }
    if (solveQueue.length === 0) {
      solving = false;
      scrambled = false;
      updateInfo();
    }
  }

  // Auto-scramble: gentle idle animation (doesn't break solve)
  if (!solving && scrambled && moveHistory.length > 0) {
    autoTimer++;
    if (autoTimer % 90 === 0) {
      const m = Math.floor(Math.random() * 6);
      const d = Math.floor(Math.random() * Math.floor(n / 2));
      MOVES[m](d);
      moveHistory.push({m, d});
    }
  }

  draw();
  requestAnimationFrame(animate);
}

// ── Events ──

// Click for desktop (touch handled separately above)
canvas.addEventListener('click', e => {
  if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;
  doScramble();
});

document.addEventListener('keydown', e => {
  // Only handle if not typing in an input
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
  if (e.key === 's' || e.key === 'S') { e.preventDefault(); cycleSize(); }
  else if (e.key === 'r' || e.key === 'R') { e.preventDefault(); doReset(); }
  else if (e.key === 'v' || e.key === 'V') { e.preventDefault(); doSolve(); }
  else if (e.key === ' ') { e.preventDefault(); doScramble(); }
});

// ── Touch Gestures ──
let touchStartX = 0, touchStartY = 0, touchStartTime = 0;
canvas.addEventListener('touchstart', e => {
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
  touchStartTime = Date.now();
}, {passive: true});
canvas.addEventListener('touchend', e => {
  const dx = e.changedTouches[0].clientX - touchStartX;
  const dy = e.changedTouches[0].clientY - touchStartY;
  const dt = Date.now() - touchStartTime;
  const dist = Math.sqrt(dx*dx + dy*dy);

  if (dist < 20 && dt < 300) {
    // Tap = scramble
    doScramble();
  } else if (dist > 50 && dt < 500) {
    if (Math.abs(dx) > Math.abs(dy)) {
      // Horizontal swipe = cycle size
      cycleSize();
    } else if (dy < 0) {
      // Swipe up = solve
      doSolve();
    } else {
      // Swipe down = reset
      doReset();
    }
  }
  e.preventDefault();
}, {passive: false});

// ── Resize ──

function resize() {
  W = canvas.width = canvas.clientWidth;
  H = canvas.height = canvas.clientHeight;
}
window.addEventListener('resize', resize);

// ── Init ──

resize();
initCube();
selfTest();
doScramble();
animate();
</script>
</body>
</html>
